"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Cryptopay API
 * Cryptopay is a payment gateway and business wallet that allows merchants to automate the processes of accepting cryptocurrency payments and payouts from their customers, as well as making currency exchange transactions and receiving data on the transaction history and account balance statuses for reporting.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionsFp = exports.SubscriptionsAxiosParamCreator = exports.Rates = exports.RatesFactory = exports.RatesFp = exports.RatesAxiosParamCreator = exports.Invoices = exports.InvoicesFactory = exports.InvoicesFp = exports.InvoicesAxiosParamCreator = exports.ExchangeTransfers = exports.ExchangeTransfersFactory = exports.ExchangeTransfersFp = exports.ExchangeTransfersAxiosParamCreator = exports.Customers = exports.CustomersFactory = exports.CustomersFp = exports.CustomersAxiosParamCreator = exports.Coins = exports.CoinsFactory = exports.CoinsFp = exports.CoinsAxiosParamCreator = exports.CoinWithdrawals = exports.CoinWithdrawalsFactory = exports.CoinWithdrawalsFp = exports.CoinWithdrawalsAxiosParamCreator = exports.Channels = exports.ChannelsFactory = exports.ChannelsFp = exports.ChannelsAxiosParamCreator = exports.Accounts = exports.AccountsFactory = exports.AccountsFp = exports.AccountsAxiosParamCreator = exports.TransactionReferenceType = exports.SubscriptionStatus = exports.SubscriptionPeriod = exports.SubscriptionCallbackEvent = exports.RiskLevel = exports.NetworkFeeLevel = exports.InvoiceStatusContext = exports.InvoiceStatus = exports.InvoiceCallbackEvent = exports.CoinWithdrawalStatus = exports.CoinWithdrawalCallbackEvent = exports.ChannelStatus = exports.ChannelPaymentStatusContext = exports.ChannelPaymentStatus = exports.ChannelPaymentCallbackEvent = exports.BeneficiaryType = void 0;
exports.Transactions = exports.TransactionsFactory = exports.TransactionsFp = exports.TransactionsAxiosParamCreator = exports.Subscriptions = exports.SubscriptionsFactory = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
var BeneficiaryType;
(function (BeneficiaryType) {
    BeneficiaryType["NaturalPerson"] = "natural_person";
    BeneficiaryType["LegalPerson"] = "legal_person";
})(BeneficiaryType = exports.BeneficiaryType || (exports.BeneficiaryType = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelPaymentCallbackEvent;
(function (ChannelPaymentCallbackEvent) {
    ChannelPaymentCallbackEvent["Created"] = "created";
    ChannelPaymentCallbackEvent["OnHold"] = "on_hold";
    ChannelPaymentCallbackEvent["Completed"] = "completed";
    ChannelPaymentCallbackEvent["Refunded"] = "refunded";
    ChannelPaymentCallbackEvent["Cancelled"] = "cancelled";
})(ChannelPaymentCallbackEvent = exports.ChannelPaymentCallbackEvent || (exports.ChannelPaymentCallbackEvent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelPaymentStatus;
(function (ChannelPaymentStatus) {
    ChannelPaymentStatus["Pending"] = "pending";
    ChannelPaymentStatus["OnHold"] = "on_hold";
    ChannelPaymentStatus["Completed"] = "completed";
    ChannelPaymentStatus["Refunded"] = "refunded";
    ChannelPaymentStatus["Cancelled"] = "cancelled";
})(ChannelPaymentStatus = exports.ChannelPaymentStatus || (exports.ChannelPaymentStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelPaymentStatusContext;
(function (ChannelPaymentStatusContext) {
    ChannelPaymentStatusContext["IllicitResource"] = "illicit_resource";
    ChannelPaymentStatusContext["ChannelDisabled"] = "channel_disabled";
})(ChannelPaymentStatusContext = exports.ChannelPaymentStatusContext || (exports.ChannelPaymentStatusContext = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelStatus;
(function (ChannelStatus) {
    ChannelStatus["Enabled"] = "enabled";
    ChannelStatus["Disabled"] = "disabled";
})(ChannelStatus = exports.ChannelStatus || (exports.ChannelStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CoinWithdrawalCallbackEvent;
(function (CoinWithdrawalCallbackEvent) {
    CoinWithdrawalCallbackEvent["Created"] = "created";
    CoinWithdrawalCallbackEvent["StatusChanged"] = "status_changed";
})(CoinWithdrawalCallbackEvent = exports.CoinWithdrawalCallbackEvent || (exports.CoinWithdrawalCallbackEvent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CoinWithdrawalStatus;
(function (CoinWithdrawalStatus) {
    CoinWithdrawalStatus["New"] = "new";
    CoinWithdrawalStatus["Pending"] = "pending";
    CoinWithdrawalStatus["OnHold"] = "on_hold";
    CoinWithdrawalStatus["Processing"] = "processing";
    CoinWithdrawalStatus["Sent"] = "sent";
    CoinWithdrawalStatus["Completed"] = "completed";
    CoinWithdrawalStatus["Failed"] = "failed";
    CoinWithdrawalStatus["Cancelled"] = "cancelled";
})(CoinWithdrawalStatus = exports.CoinWithdrawalStatus || (exports.CoinWithdrawalStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var InvoiceCallbackEvent;
(function (InvoiceCallbackEvent) {
    InvoiceCallbackEvent["Created"] = "created";
    InvoiceCallbackEvent["Refunded"] = "refunded";
    InvoiceCallbackEvent["Recalculated"] = "recalculated";
    InvoiceCallbackEvent["StatusChanged"] = "status_changed";
    InvoiceCallbackEvent["TransactionCreated"] = "transaction_created";
    InvoiceCallbackEvent["TransactionConfirmed"] = "transaction_confirmed";
})(InvoiceCallbackEvent = exports.InvoiceCallbackEvent || (exports.InvoiceCallbackEvent = {}));
/**
 * Invoice status
 * @export
 * @enum {string}
 */
var InvoiceStatus;
(function (InvoiceStatus) {
    InvoiceStatus["New"] = "new";
    InvoiceStatus["Completed"] = "completed";
    InvoiceStatus["Unresolved"] = "unresolved";
    InvoiceStatus["Refunded"] = "refunded";
    InvoiceStatus["Cancelled"] = "cancelled";
})(InvoiceStatus = exports.InvoiceStatus || (exports.InvoiceStatus = {}));
/**
 * Invoice status context
 * @export
 * @enum {string}
 */
var InvoiceStatusContext;
(function (InvoiceStatusContext) {
    InvoiceStatusContext["Overpaid"] = "overpaid";
    InvoiceStatusContext["Underpaid"] = "underpaid";
    InvoiceStatusContext["PaidLate"] = "paid_late";
    InvoiceStatusContext["IllicitResource"] = "illicit_resource";
})(InvoiceStatusContext = exports.InvoiceStatusContext || (exports.InvoiceStatusContext = {}));
/**
 *
 * @export
 * @enum {string}
 */
var NetworkFeeLevel;
(function (NetworkFeeLevel) {
    NetworkFeeLevel["Fast"] = "fast";
    NetworkFeeLevel["Average"] = "average";
    NetworkFeeLevel["Slow"] = "slow";
})(NetworkFeeLevel = exports.NetworkFeeLevel || (exports.NetworkFeeLevel = {}));
/**
 * Transaction risk level depending on the `score` value
 * @export
 * @enum {string}
 */
var RiskLevel;
(function (RiskLevel) {
    RiskLevel["Low"] = "low";
    RiskLevel["Medium"] = "medium";
    RiskLevel["High"] = "high";
})(RiskLevel = exports.RiskLevel || (exports.RiskLevel = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SubscriptionCallbackEvent;
(function (SubscriptionCallbackEvent) {
    SubscriptionCallbackEvent["Paid"] = "paid";
    SubscriptionCallbackEvent["Cancelled"] = "cancelled";
})(SubscriptionCallbackEvent = exports.SubscriptionCallbackEvent || (exports.SubscriptionCallbackEvent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var SubscriptionPeriod;
(function (SubscriptionPeriod) {
    SubscriptionPeriod["Day"] = "day";
    SubscriptionPeriod["Week"] = "week";
    SubscriptionPeriod["Month"] = "month";
    SubscriptionPeriod["Year"] = "year";
})(SubscriptionPeriod = exports.SubscriptionPeriod || (exports.SubscriptionPeriod = {}));
/**
 * Subscription status
 * @export
 * @enum {string}
 */
var SubscriptionStatus;
(function (SubscriptionStatus) {
    SubscriptionStatus["Active"] = "active";
    SubscriptionStatus["Cancelled"] = "cancelled";
})(SubscriptionStatus = exports.SubscriptionStatus || (exports.SubscriptionStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var TransactionReferenceType;
(function (TransactionReferenceType) {
    TransactionReferenceType["BankDeposit"] = "BankDeposit";
    TransactionReferenceType["BankWithdrawal"] = "BankWithdrawal";
    TransactionReferenceType["ChannelPayment"] = "ChannelPayment";
    TransactionReferenceType["CoinDeposit"] = "CoinDeposit";
    TransactionReferenceType["CoinWithdrawal"] = "CoinWithdrawal";
    TransactionReferenceType["ExchangeTransfer"] = "ExchangeTransfer";
    TransactionReferenceType["Invoice"] = "Invoice";
    TransactionReferenceType["InvoiceRefund"] = "InvoiceRefund";
    TransactionReferenceType["ManualBalanceTransaction"] = "ManualBalanceTransaction";
})(TransactionReferenceType = exports.TransactionReferenceType || (exports.TransactionReferenceType = {}));
/**
 * Accounts - axios parameter creator
 * @export
 */
const AccountsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: (accountId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('listTransactions', 'accountId', accountId);
            const localVarPath = `/api/accounts/{account_id}/transactions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountsAxiosParamCreator = AccountsAxiosParamCreator;
/**
 * Accounts - functional programming interface
 * @export
 */
const AccountsFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountsAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accountId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactions(accountId, startingAfter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AccountsFp = AccountsFp;
/**
 * Accounts - factory interface
 * @export
 */
const AccountsFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountsFp)(configuration);
    return {
        /**
         *
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options) {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accountId, startingAfter, options) {
            return localVarFp.listTransactions(accountId, startingAfter, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsFactory = AccountsFactory;
/**
 * Accounts - object-oriented interface
 * @export
 * @class Accounts
 * @extends {BaseAPI}
 */
class Accounts extends base_1.BaseAPI {
    /**
     *
     * @summary List accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Accounts
     */
    list(options) {
        return (0, exports.AccountsFp)(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List account transactions
     * @param {string} accountId Account ID
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Accounts
     */
    listTransactions(accountId, startingAfter, options) {
        return (0, exports.AccountsFp)(this.configuration).listTransactions(accountId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Accounts = Accounts;
/**
 * Channels - axios parameter creator
 * @export
 */
const ChannelsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a channel
         * @param {ChannelParams} channelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (channelParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelParams' is not null or undefined
            (0, common_1.assertParamExists)('create', 'channelParams', channelParams);
            const localVarPath = `/api/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(channelParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (customerId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: (channelId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('listPayments', 'channelId', channelId);
            const localVarPath = `/api/channels/{channel_id}/payments`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (channelId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'channelId', channelId);
            const localVarPath = `/api/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a channel by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: (customId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveByCustomId', 'customId', customId);
            const localVarPath = `/api/channels/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment: (channelId, channelPaymentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('retrievePayment', 'channelId', channelId);
            // verify required parameter 'channelPaymentId' is not null or undefined
            (0, common_1.assertParamExists)('retrievePayment', 'channelPaymentId', channelPaymentId);
            const localVarPath = `/api/channels/{channel_id}/payments/{channel_payment_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"channel_payment_id"}}`, encodeURIComponent(String(channelPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (channelId, channelUpdateParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            (0, common_1.assertParamExists)('update', 'channelId', channelId);
            // verify required parameter 'channelUpdateParams' is not null or undefined
            (0, common_1.assertParamExists)('update', 'channelUpdateParams', channelUpdateParams);
            const localVarPath = `/api/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(channelUpdateParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ChannelsAxiosParamCreator = ChannelsAxiosParamCreator;
/**
 * Channels - functional programming interface
 * @export
 */
const ChannelsFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ChannelsAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a channel
         * @param {ChannelParams} channelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(channelParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(channelParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(customerId, startingAfter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(channelId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPayments(channelId, startingAfter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(channelId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(channelId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a channel by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveByCustomId(customId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment(channelId, channelPaymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrievePayment(channelId, channelPaymentId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(channelId, channelUpdateParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.update(channelId, channelUpdateParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ChannelsFp = ChannelsFp;
/**
 * Channels - factory interface
 * @export
 */
const ChannelsFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ChannelsFp)(configuration);
    return {
        /**
         *
         * @summary Create a channel
         * @param {ChannelParams} channelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(channelParams, options) {
            return localVarFp.create(channelParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(channelId, startingAfter, options) {
            return localVarFp.listPayments(channelId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(channelId, options) {
            return localVarFp.retrieve(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a channel by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment(channelId, channelPaymentId, options) {
            return localVarFp.retrievePayment(channelId, channelPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(channelId, channelUpdateParams, options) {
            return localVarFp.update(channelId, channelUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ChannelsFactory = ChannelsFactory;
/**
 * Channels - object-oriented interface
 * @export
 * @class Channels
 * @extends {BaseAPI}
 */
class Channels extends base_1.BaseAPI {
    /**
     *
     * @summary Create a channel
     * @param {ChannelParams} channelParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    create(channelParams, options) {
        return (0, exports.ChannelsFp)(this.configuration).create(channelParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List channels
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    list(customerId, startingAfter, options) {
        return (0, exports.ChannelsFp)(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List channel payments
     * @param {string} channelId Channel ID
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    listPayments(channelId, startingAfter, options) {
        return (0, exports.ChannelsFp)(this.configuration).listPayments(channelId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a channel
     * @param {string} channelId Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    retrieve(channelId, options) {
        return (0, exports.ChannelsFp)(this.configuration).retrieve(channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a channel by custom id
     * @param {string} customId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    retrieveByCustomId(customId, options) {
        return (0, exports.ChannelsFp)(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a channel payment
     * @param {string} channelId Channel ID
     * @param {string} channelPaymentId Channel payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    retrievePayment(channelId, channelPaymentId, options) {
        return (0, exports.ChannelsFp)(this.configuration).retrievePayment(channelId, channelPaymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a channel
     * @param {string} channelId Channel ID
     * @param {ChannelUpdateParams} channelUpdateParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    update(channelId, channelUpdateParams, options) {
        return (0, exports.ChannelsFp)(this.configuration).update(channelId, channelUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Channels = Channels;
/**
 * CoinWithdrawals - axios parameter creator
 * @export
 */
const CoinWithdrawalsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: (coinWithdrawalId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coinWithdrawalId' is not null or undefined
            (0, common_1.assertParamExists)('commit', 'coinWithdrawalId', coinWithdrawalId);
            const localVarPath = `/api/coin_withdrawals/{coin_withdrawal_id}/commit`
                .replace(`{${"coin_withdrawal_id"}}`, encodeURIComponent(String(coinWithdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * To create a withdrawal you need to use either `charged_amount`, `charged_amount_to_send` or `received_amount` parameters in your request body.
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (coinWithdrawalParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coinWithdrawalParams' is not null or undefined
            (0, common_1.assertParamExists)('create', 'coinWithdrawalParams', coinWithdrawalParams);
            const localVarPath = `/api/coin_withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(coinWithdrawalParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (customerId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/coin_withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List network fees
         * @param {boolean} [allNetworks] Is &#x60;false&#x60; if omitted. Set &#x60;true&#x60; to return network fees for all cryptocurrency networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees: (allNetworks, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/coin_withdrawals/network_fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (allNetworks !== undefined) {
                localVarQueryParameter['all_networks'] = allNetworks;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (coinWithdrawalId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coinWithdrawalId' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'coinWithdrawalId', coinWithdrawalId);
            const localVarPath = `/api/coin_withdrawals/{coin_withdrawal_id}`
                .replace(`{${"coin_withdrawal_id"}}`, encodeURIComponent(String(coinWithdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: (customId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveByCustomId', 'customId', customId);
            const localVarPath = `/api/coin_withdrawals/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CoinWithdrawalsAxiosParamCreator = CoinWithdrawalsAxiosParamCreator;
/**
 * CoinWithdrawals - functional programming interface
 * @export
 */
const CoinWithdrawalsFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CoinWithdrawalsAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(coinWithdrawalId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commit(coinWithdrawalId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * To create a withdrawal you need to use either `charged_amount`, `charged_amount_to_send` or `received_amount` parameters in your request body.
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(coinWithdrawalParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(coinWithdrawalParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(customerId, startingAfter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List network fees
         * @param {boolean} [allNetworks] Is &#x60;false&#x60; if omitted. Set &#x60;true&#x60; to return network fees for all cryptocurrency networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees(allNetworks, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listNetworkFees(allNetworks, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(coinWithdrawalId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(coinWithdrawalId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveByCustomId(customId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CoinWithdrawalsFp = CoinWithdrawalsFp;
/**
 * CoinWithdrawals - factory interface
 * @export
 */
const CoinWithdrawalsFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CoinWithdrawalsFp)(configuration);
    return {
        /**
         *
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(coinWithdrawalId, options) {
            return localVarFp.commit(coinWithdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * To create a withdrawal you need to use either `charged_amount`, `charged_amount_to_send` or `received_amount` parameters in your request body.
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(coinWithdrawalParams, options) {
            return localVarFp.create(coinWithdrawalParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List network fees
         * @param {boolean} [allNetworks] Is &#x60;false&#x60; if omitted. Set &#x60;true&#x60; to return network fees for all cryptocurrency networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees(allNetworks, options) {
            return localVarFp.listNetworkFees(allNetworks, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(coinWithdrawalId, options) {
            return localVarFp.retrieve(coinWithdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CoinWithdrawalsFactory = CoinWithdrawalsFactory;
/**
 * CoinWithdrawals - object-oriented interface
 * @export
 * @class CoinWithdrawals
 * @extends {BaseAPI}
 */
class CoinWithdrawals extends base_1.BaseAPI {
    /**
     *
     * @summary Commit a withdrawal
     * @param {string} coinWithdrawalId Coin withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    commit(coinWithdrawalId, options) {
        return (0, exports.CoinWithdrawalsFp)(this.configuration).commit(coinWithdrawalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * To create a withdrawal you need to use either `charged_amount`, `charged_amount_to_send` or `received_amount` parameters in your request body.
     * @summary Create a withdrawal
     * @param {CoinWithdrawalParams} coinWithdrawalParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    create(coinWithdrawalParams, options) {
        return (0, exports.CoinWithdrawalsFp)(this.configuration).create(coinWithdrawalParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List withdrawals
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    list(customerId, startingAfter, options) {
        return (0, exports.CoinWithdrawalsFp)(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List network fees
     * @param {boolean} [allNetworks] Is &#x60;false&#x60; if omitted. Set &#x60;true&#x60; to return network fees for all cryptocurrency networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    listNetworkFees(allNetworks, options) {
        return (0, exports.CoinWithdrawalsFp)(this.configuration).listNetworkFees(allNetworks, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a withdrawal
     * @param {string} coinWithdrawalId Coin withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    retrieve(coinWithdrawalId, options) {
        return (0, exports.CoinWithdrawalsFp)(this.configuration).retrieve(coinWithdrawalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a withdrawal by custom id
     * @param {string} customId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    retrieveByCustomId(customId, options) {
        return (0, exports.CoinWithdrawalsFp)(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CoinWithdrawals = CoinWithdrawals;
/**
 * Coins - axios parameter creator
 * @export
 */
const CoinsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List supported coins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CoinsAxiosParamCreator = CoinsAxiosParamCreator;
/**
 * Coins - functional programming interface
 * @export
 */
const CoinsFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CoinsAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary List supported coins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CoinsFp = CoinsFp;
/**
 * Coins - factory interface
 * @export
 */
const CoinsFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CoinsFp)(configuration);
    return {
        /**
         *
         * @summary List supported coins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options) {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
    };
};
exports.CoinsFactory = CoinsFactory;
/**
 * Coins - object-oriented interface
 * @export
 * @class Coins
 * @extends {BaseAPI}
 */
class Coins extends base_1.BaseAPI {
    /**
     *
     * @summary List supported coins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Coins
     */
    list(options) {
        return (0, exports.CoinsFp)(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Coins = Coins;
/**
 * Customers - axios parameter creator
 * @export
 */
const CustomersAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a customer
         * @param {CustomerParams} customerParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (customerParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerParams' is not null or undefined
            (0, common_1.assertParamExists)('create', 'customerParams', customerParams);
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(customerParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (customerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'customerId', customerId);
            const localVarPath = `/api/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (customerId, customerUpdateParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            (0, common_1.assertParamExists)('update', 'customerId', customerId);
            // verify required parameter 'customerUpdateParams' is not null or undefined
            (0, common_1.assertParamExists)('update', 'customerUpdateParams', customerUpdateParams);
            const localVarPath = `/api/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(customerUpdateParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CustomersAxiosParamCreator = CustomersAxiosParamCreator;
/**
 * Customers - functional programming interface
 * @export
 */
const CustomersFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CustomersAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a customer
         * @param {CustomerParams} customerParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(customerParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(customerParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(startingAfter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(customerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(customerId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(customerId, customerUpdateParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.update(customerId, customerUpdateParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CustomersFp = CustomersFp;
/**
 * Customers - factory interface
 * @export
 */
const CustomersFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CustomersFp)(configuration);
    return {
        /**
         *
         * @summary Create a customer
         * @param {CustomerParams} customerParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(customerParams, options) {
            return localVarFp.create(customerParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(startingAfter, options) {
            return localVarFp.list(startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(customerId, options) {
            return localVarFp.retrieve(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(customerId, customerUpdateParams, options) {
            return localVarFp.update(customerId, customerUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CustomersFactory = CustomersFactory;
/**
 * Customers - object-oriented interface
 * @export
 * @class Customers
 * @extends {BaseAPI}
 */
class Customers extends base_1.BaseAPI {
    /**
     *
     * @summary Create a customer
     * @param {CustomerParams} customerParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    create(customerParams, options) {
        return (0, exports.CustomersFp)(this.configuration).create(customerParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List customers
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    list(startingAfter, options) {
        return (0, exports.CustomersFp)(this.configuration).list(startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a customer
     * @param {string} customerId The customer\&#39;s reference ID in your system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    retrieve(customerId, options) {
        return (0, exports.CustomersFp)(this.configuration).retrieve(customerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a customer
     * @param {string} customerId The customer\&#39;s reference ID in your system
     * @param {CustomerUpdateParams} customerUpdateParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    update(customerId, customerUpdateParams, options) {
        return (0, exports.CustomersFp)(this.configuration).update(customerId, customerUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Customers = Customers;
/**
 * ExchangeTransfers - axios parameter creator
 * @export
 */
const ExchangeTransfersAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: (exchangeTransferId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'exchangeTransferId' is not null or undefined
            (0, common_1.assertParamExists)('commit', 'exchangeTransferId', exchangeTransferId);
            const localVarPath = `/api/exchange_transfers/{exchange_transfer_id}/commit`
                .replace(`{${"exchange_transfer_id"}}`, encodeURIComponent(String(exchangeTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (exchangeTransferParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'exchangeTransferParams' is not null or undefined
            (0, common_1.assertParamExists)('create', 'exchangeTransferParams', exchangeTransferParams);
            const localVarPath = `/api/exchange_transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(exchangeTransferParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (exchangeTransferId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'exchangeTransferId' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'exchangeTransferId', exchangeTransferId);
            const localVarPath = `/api/exchange_transfers/{exchange_transfer_id}`
                .replace(`{${"exchange_transfer_id"}}`, encodeURIComponent(String(exchangeTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ExchangeTransfersAxiosParamCreator = ExchangeTransfersAxiosParamCreator;
/**
 * ExchangeTransfers - functional programming interface
 * @export
 */
const ExchangeTransfersFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ExchangeTransfersAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(exchangeTransferId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commit(exchangeTransferId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(exchangeTransferParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(exchangeTransferParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(exchangeTransferId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(exchangeTransferId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ExchangeTransfersFp = ExchangeTransfersFp;
/**
 * ExchangeTransfers - factory interface
 * @export
 */
const ExchangeTransfersFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ExchangeTransfersFp)(configuration);
    return {
        /**
         *
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(exchangeTransferId, options) {
            return localVarFp.commit(exchangeTransferId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(exchangeTransferParams, options) {
            return localVarFp.create(exchangeTransferParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(exchangeTransferId, options) {
            return localVarFp.retrieve(exchangeTransferId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ExchangeTransfersFactory = ExchangeTransfersFactory;
/**
 * ExchangeTransfers - object-oriented interface
 * @export
 * @class ExchangeTransfers
 * @extends {BaseAPI}
 */
class ExchangeTransfers extends base_1.BaseAPI {
    /**
     *
     * @summary Commit an exchange transfer
     * @param {string} exchangeTransferId Exchange transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    commit(exchangeTransferId, options) {
        return (0, exports.ExchangeTransfersFp)(this.configuration).commit(exchangeTransferId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an exchange transfer
     * @param {ExchangeTransferParams} exchangeTransferParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    create(exchangeTransferParams, options) {
        return (0, exports.ExchangeTransfersFp)(this.configuration).create(exchangeTransferParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an exchange transfer
     * @param {string} exchangeTransferId Exchange transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    retrieve(exchangeTransferId, options) {
        return (0, exports.ExchangeTransfersFp)(this.configuration).retrieve(exchangeTransferId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExchangeTransfers = ExchangeTransfers;
/**
 * Invoices - axios parameter creator
 * @export
 */
const InvoicesAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation: (invoiceId, recalculationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('commitRecalculation', 'invoiceId', invoiceId);
            // verify required parameter 'recalculationId' is not null or undefined
            (0, common_1.assertParamExists)('commitRecalculation', 'recalculationId', recalculationId);
            const localVarPath = `/api/invoices/{invoice_id}/recalculations/{recalculation_id}/commit`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"recalculation_id"}}`, encodeURIComponent(String(recalculationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (invoiceParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceParams' is not null or undefined
            (0, common_1.assertParamExists)('create', 'invoiceParams', invoiceParams);
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(invoiceParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation: (invoiceId, invoiceRecalculationParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('createRecalculation', 'invoiceId', invoiceId);
            // verify required parameter 'invoiceRecalculationParams' is not null or undefined
            (0, common_1.assertParamExists)('createRecalculation', 'invoiceRecalculationParams', invoiceRecalculationParams);
            const localVarPath = `/api/invoices/{invoice_id}/recalculations`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(invoiceRecalculationParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund: (invoiceId, invoiceRefundParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('createRefund', 'invoiceId', invoiceId);
            // verify required parameter 'invoiceRefundParams' is not null or undefined
            (0, common_1.assertParamExists)('createRefund', 'invoiceRefundParams', invoiceRefundParams);
            const localVarPath = `/api/invoices/{invoice_id}/refunds`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(invoiceRefundParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {string} [subscriptionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (customerId, startingAfter, subscriptionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscription_id'] = subscriptionId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds: (invoiceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('listRefunds', 'invoiceId', invoiceId);
            const localVarPath = `/api/invoices/{invoice_id}/refunds`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (invoiceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'invoiceId', invoiceId);
            const localVarPath = `/api/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: (customId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveByCustomId', 'customId', customId);
            const localVarPath = `/api/invoices/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvoicesAxiosParamCreator = InvoicesAxiosParamCreator;
/**
 * Invoices - functional programming interface
 * @export
 */
const InvoicesFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InvoicesAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation(invoiceId, recalculationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commitRecalculation(invoiceId, recalculationId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(invoiceParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(invoiceParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation(invoiceId, invoiceRecalculationParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRecalculation(invoiceId, invoiceRecalculationParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(invoiceId, invoiceRefundParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRefund(invoiceId, invoiceRefundParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {string} [subscriptionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(customerId, startingAfter, subscriptionId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRefunds(invoiceId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(invoiceId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveByCustomId(customId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvoicesFp = InvoicesFp;
/**
 * Invoices - factory interface
 * @export
 */
const InvoicesFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InvoicesFp)(configuration);
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation(invoiceId, recalculationId, options) {
            return localVarFp.commitRecalculation(invoiceId, recalculationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(invoiceParams, options) {
            return localVarFp.create(invoiceParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation(invoiceId, invoiceRecalculationParams, options) {
            return localVarFp.createRecalculation(invoiceId, invoiceRecalculationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(invoiceId, invoiceRefundParams, options) {
            return localVarFp.createRefund(invoiceId, invoiceRefundParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {string} [subscriptionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, subscriptionId, options) {
            return localVarFp.list(customerId, startingAfter, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(invoiceId, options) {
            return localVarFp.listRefunds(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(invoiceId, options) {
            return localVarFp.retrieve(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvoicesFactory = InvoicesFactory;
/**
 * Invoices - object-oriented interface
 * @export
 * @class Invoices
 * @extends {BaseAPI}
 */
class Invoices extends base_1.BaseAPI {
    /**
     * This endpoint allows you to commit invoice recalculation.
     * @summary Commit invoice recalculation
     * @param {string} invoiceId Invoice ID
     * @param {string} recalculationId Recalculation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    commitRecalculation(invoiceId, recalculationId, options) {
        return (0, exports.InvoicesFp)(this.configuration).commitRecalculation(invoiceId, recalculationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to create invoices.
     * @summary Create an invoice
     * @param {InvoiceParams} invoiceParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    create(invoiceParams, options) {
        return (0, exports.InvoicesFp)(this.configuration).create(invoiceParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to recalculate invoices.
     * @summary Create invoice recalculation
     * @param {string} invoiceId Invoice ID
     * @param {InvoiceRecalculationParams} invoiceRecalculationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    createRecalculation(invoiceId, invoiceRecalculationParams, options) {
        return (0, exports.InvoicesFp)(this.configuration).createRecalculation(invoiceId, invoiceRecalculationParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to create invoice refunds.
     * @summary Create invoice refund
     * @param {string} invoiceId Invoice ID
     * @param {InvoiceRefundParams} invoiceRefundParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    createRefund(invoiceId, invoiceRefundParams, options) {
        return (0, exports.InvoicesFp)(this.configuration).createRefund(invoiceId, invoiceRefundParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve a list of all invoices.
     * @summary List invoices
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {string} [subscriptionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    list(customerId, startingAfter, subscriptionId, options) {
        return (0, exports.InvoicesFp)(this.configuration).list(customerId, startingAfter, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve a list of a particular invoice refunds.
     * @summary List invoice refunds
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    listRefunds(invoiceId, options) {
        return (0, exports.InvoicesFp)(this.configuration).listRefunds(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve the invoice details.
     * @summary Retrieve an invoice
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    retrieve(invoiceId, options) {
        return (0, exports.InvoicesFp)(this.configuration).retrieve(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve invoice details by its custom_id.
     * @summary Retrieve an invoice by custom_id
     * @param {string} customId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    retrieveByCustomId(customId, options) {
        return (0, exports.InvoicesFp)(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Invoices = Invoices;
/**
 * Rates - axios parameter creator
 * @export
 */
const RatesAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (baseCurrency, quoteCurrency, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'baseCurrency' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'baseCurrency', baseCurrency);
            // verify required parameter 'quoteCurrency' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'quoteCurrency', quoteCurrency);
            const localVarPath = `/api/rates/{base_currency}/{quote_currency}`
                .replace(`{${"base_currency"}}`, encodeURIComponent(String(baseCurrency)))
                .replace(`{${"quote_currency"}}`, encodeURIComponent(String(quoteCurrency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RatesAxiosParamCreator = RatesAxiosParamCreator;
/**
 * Rates - functional programming interface
 * @export
 */
const RatesFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RatesAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.all(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(baseCurrency, quoteCurrency, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(baseCurrency, quoteCurrency, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.RatesFp = RatesFp;
/**
 * Rates - factory interface
 * @export
 */
const RatesFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RatesFp)(configuration);
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options) {
            return localVarFp.all(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(baseCurrency, quoteCurrency, options) {
            return localVarFp.retrieve(baseCurrency, quoteCurrency, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RatesFactory = RatesFactory;
/**
 * Rates - object-oriented interface
 * @export
 * @class Rates
 * @extends {BaseAPI}
 */
class Rates extends base_1.BaseAPI {
    /**
     * This endpoint allows you to retrieve all public rates.
     * @summary Retrieve all rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Rates
     */
    all(options) {
        return (0, exports.RatesFp)(this.configuration).all(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve a public rate by currency pair.
     * @summary Retrieve a pair rate
     * @param {string} baseCurrency Base currency of pair
     * @param {string} quoteCurrency Quote currency of pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Rates
     */
    retrieve(baseCurrency, quoteCurrency, options) {
        return (0, exports.RatesFp)(this.configuration).retrieve(baseCurrency, quoteCurrency, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Rates = Rates;
/**
 * Subscriptions - axios parameter creator
 * @export
 */
const SubscriptionsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Cancel a subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: (subscriptionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('cancel', 'subscriptionId', subscriptionId);
            const localVarPath = `/api/subscriptions/{subscription_id}/cancel`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a subscription
         * @param {SubscriptionParams} subscriptionParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (subscriptionParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionParams' is not null or undefined
            (0, common_1.assertParamExists)('create', 'subscriptionParams', subscriptionParams);
            const localVarPath = `/api/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(subscriptionParams, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List subscriptions
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (subscriptionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('retrieve', 'subscriptionId', subscriptionId);
            const localVarPath = `/api/subscriptions/{subscription_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a subscription by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: (customId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveByCustomId', 'customId', customId);
            const localVarPath = `/api/subscriptions/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SubscriptionsAxiosParamCreator = SubscriptionsAxiosParamCreator;
/**
 * Subscriptions - functional programming interface
 * @export
 */
const SubscriptionsFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SubscriptionsAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Cancel a subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancel(subscriptionId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create a subscription
         * @param {SubscriptionParams} subscriptionParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(subscriptionParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(subscriptionParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List subscriptions
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(startingAfter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(subscriptionId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a subscription by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveByCustomId(customId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SubscriptionsFp = SubscriptionsFp;
/**
 * Subscriptions - factory interface
 * @export
 */
const SubscriptionsFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SubscriptionsFp)(configuration);
    return {
        /**
         *
         * @summary Cancel a subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(subscriptionId, options) {
            return localVarFp.cancel(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a subscription
         * @param {SubscriptionParams} subscriptionParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(subscriptionParams, options) {
            return localVarFp.create(subscriptionParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List subscriptions
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(startingAfter, options) {
            return localVarFp.list(startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(subscriptionId, options) {
            return localVarFp.retrieve(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a subscription by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SubscriptionsFactory = SubscriptionsFactory;
/**
 * Subscriptions - object-oriented interface
 * @export
 * @class Subscriptions
 * @extends {BaseAPI}
 */
class Subscriptions extends base_1.BaseAPI {
    /**
     *
     * @summary Cancel a subscription
     * @param {string} subscriptionId Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Subscriptions
     */
    cancel(subscriptionId, options) {
        return (0, exports.SubscriptionsFp)(this.configuration).cancel(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a subscription
     * @param {SubscriptionParams} subscriptionParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Subscriptions
     */
    create(subscriptionParams, options) {
        return (0, exports.SubscriptionsFp)(this.configuration).create(subscriptionParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List subscriptions
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Subscriptions
     */
    list(startingAfter, options) {
        return (0, exports.SubscriptionsFp)(this.configuration).list(startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a subscription
     * @param {string} subscriptionId Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Subscriptions
     */
    retrieve(subscriptionId, options) {
        return (0, exports.SubscriptionsFp)(this.configuration).retrieve(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a subscription by custom_id
     * @param {string} customId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Subscriptions
     */
    retrieveByCustomId(customId, options) {
        return (0, exports.SubscriptionsFp)(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Subscriptions = Subscriptions;
/**
 * Transactions - axios parameter creator
 * @export
 */
const TransactionsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom instanceof Date) ?
                    createdAtFrom.toISOString() :
                    createdAtFrom;
            }
            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo instanceof Date) ?
                    createdAtTo.toISOString() :
                    createdAtTo;
            }
            if (referenceType !== undefined) {
                localVarQueryParameter['reference_type'] = referenceType;
            }
            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (riskLevel !== undefined) {
                localVarQueryParameter['risk_level'] = riskLevel;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionsAxiosParamCreator = TransactionsAxiosParamCreator;
/**
 * Transactions - functional programming interface
 * @export
 */
const TransactionsFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionsAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TransactionsFp = TransactionsFp;
/**
 * Transactions - factory interface
 * @export
 */
const TransactionsFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionsFp)(configuration);
    return {
        /**
         *
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options) {
            return localVarFp.list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionsFactory = TransactionsFactory;
/**
 * Transactions - object-oriented interface
 * @export
 * @class Transactions
 * @extends {BaseAPI}
 */
class Transactions extends base_1.BaseAPI {
    /**
     *
     * @summary List transactions
     * @param {string} [createdAtFrom] Date and time in iso8601 format
     * @param {string} [createdAtTo] Date and time in iso8601 format
     * @param {TransactionReferenceType} [referenceType] Transaction reference type
     * @param {string} [currency] Transaction currency
     * @param {string} [status] Transaction status
     * @param {RiskLevel} [riskLevel] Transaction risk level
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Transactions
     */
    list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options) {
        return (0, exports.TransactionsFp)(this.configuration).list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Transactions = Transactions;
