"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Cryptopay API
 * Cryptopay is a payment gateway and business wallet that allows merchants to automate the processes of accepting cryptocurrency payments and payouts from their customers, as well as making currency exchange transactions and receiving data on the transaction history and account balance statuses for reporting.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transactions = exports.TransactionsFactory = exports.TransactionsFp = exports.TransactionsAxiosParamCreator = exports.Risks = exports.RisksFactory = exports.RisksFp = exports.RisksAxiosParamCreator = exports.Rates = exports.RatesFactory = exports.RatesFp = exports.RatesAxiosParamCreator = exports.Invoices = exports.InvoicesFactory = exports.InvoicesFp = exports.InvoicesAxiosParamCreator = exports.ExchangeTransfers = exports.ExchangeTransfersFactory = exports.ExchangeTransfersFp = exports.ExchangeTransfersAxiosParamCreator = exports.Customers = exports.CustomersFactory = exports.CustomersFp = exports.CustomersAxiosParamCreator = exports.CoinWithdrawals = exports.CoinWithdrawalsFactory = exports.CoinWithdrawalsFp = exports.CoinWithdrawalsAxiosParamCreator = exports.Channels = exports.ChannelsFactory = exports.ChannelsFp = exports.ChannelsAxiosParamCreator = exports.Accounts = exports.AccountsFactory = exports.AccountsFp = exports.AccountsAxiosParamCreator = exports.TransactionReferenceType = exports.RiskParamsTypeEnum = exports.RiskLevel = exports.NetworkFeeLevel = exports.InvoiceStatusContext = exports.InvoiceStatus = exports.InvoiceCallbackEvent = exports.InvoiceCallbackTypeEnum = exports.CoinWithdrawalStatus = exports.CoinWithdrawalCallbackEvent = exports.CoinWithdrawalCallbackTypeEnum = exports.ChannelStatus = exports.ChannelPaymentStatusContext = exports.ChannelPaymentStatus = exports.ChannelPaymentCallbackEvent = exports.ChannelPaymentCallbackTypeEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var ChannelPaymentCallbackTypeEnum;
(function (ChannelPaymentCallbackTypeEnum) {
    ChannelPaymentCallbackTypeEnum["ChannelPayment"] = "ChannelPayment";
})(ChannelPaymentCallbackTypeEnum = exports.ChannelPaymentCallbackTypeEnum || (exports.ChannelPaymentCallbackTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelPaymentCallbackEvent;
(function (ChannelPaymentCallbackEvent) {
    ChannelPaymentCallbackEvent["Created"] = "created";
    ChannelPaymentCallbackEvent["OnHold"] = "on_hold";
    ChannelPaymentCallbackEvent["Completed"] = "completed";
    ChannelPaymentCallbackEvent["Refunded"] = "refunded";
    ChannelPaymentCallbackEvent["Cancelled"] = "cancelled";
})(ChannelPaymentCallbackEvent = exports.ChannelPaymentCallbackEvent || (exports.ChannelPaymentCallbackEvent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelPaymentStatus;
(function (ChannelPaymentStatus) {
    ChannelPaymentStatus["Pending"] = "pending";
    ChannelPaymentStatus["OnHold"] = "on_hold";
    ChannelPaymentStatus["Completed"] = "completed";
    ChannelPaymentStatus["Refunded"] = "refunded";
    ChannelPaymentStatus["Cancelled"] = "cancelled";
})(ChannelPaymentStatus = exports.ChannelPaymentStatus || (exports.ChannelPaymentStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelPaymentStatusContext;
(function (ChannelPaymentStatusContext) {
    ChannelPaymentStatusContext["IllicitResource"] = "illicit_resource";
    ChannelPaymentStatusContext["ChannelDisabled"] = "channel_disabled";
})(ChannelPaymentStatusContext = exports.ChannelPaymentStatusContext || (exports.ChannelPaymentStatusContext = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ChannelStatus;
(function (ChannelStatus) {
    ChannelStatus["Enabled"] = "enabled";
    ChannelStatus["Disabled"] = "disabled";
})(ChannelStatus = exports.ChannelStatus || (exports.ChannelStatus = {}));
/**
    * @export
    * @enum {string}
    */
var CoinWithdrawalCallbackTypeEnum;
(function (CoinWithdrawalCallbackTypeEnum) {
    CoinWithdrawalCallbackTypeEnum["CoinWithdrawal"] = "CoinWithdrawal";
})(CoinWithdrawalCallbackTypeEnum = exports.CoinWithdrawalCallbackTypeEnum || (exports.CoinWithdrawalCallbackTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CoinWithdrawalCallbackEvent;
(function (CoinWithdrawalCallbackEvent) {
    CoinWithdrawalCallbackEvent["Created"] = "created";
    CoinWithdrawalCallbackEvent["StatusChanged"] = "status_changed";
})(CoinWithdrawalCallbackEvent = exports.CoinWithdrawalCallbackEvent || (exports.CoinWithdrawalCallbackEvent = {}));
/**
 *
 * @export
 * @enum {string}
 */
var CoinWithdrawalStatus;
(function (CoinWithdrawalStatus) {
    CoinWithdrawalStatus["New"] = "new";
    CoinWithdrawalStatus["Pending"] = "pending";
    CoinWithdrawalStatus["OnHold"] = "on_hold";
    CoinWithdrawalStatus["Processing"] = "processing";
    CoinWithdrawalStatus["Sent"] = "sent";
    CoinWithdrawalStatus["Completed"] = "completed";
    CoinWithdrawalStatus["Failed"] = "failed";
    CoinWithdrawalStatus["Cancelled"] = "cancelled";
})(CoinWithdrawalStatus = exports.CoinWithdrawalStatus || (exports.CoinWithdrawalStatus = {}));
/**
    * @export
    * @enum {string}
    */
var InvoiceCallbackTypeEnum;
(function (InvoiceCallbackTypeEnum) {
    InvoiceCallbackTypeEnum["Invoice"] = "Invoice";
})(InvoiceCallbackTypeEnum = exports.InvoiceCallbackTypeEnum || (exports.InvoiceCallbackTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var InvoiceCallbackEvent;
(function (InvoiceCallbackEvent) {
    InvoiceCallbackEvent["Created"] = "created";
    InvoiceCallbackEvent["Refunded"] = "refunded";
    InvoiceCallbackEvent["Recalculated"] = "recalculated";
    InvoiceCallbackEvent["StatusChanged"] = "status_changed";
    InvoiceCallbackEvent["TransactionCreated"] = "transaction_created";
    InvoiceCallbackEvent["TransactionConfirmed"] = "transaction_confirmed";
})(InvoiceCallbackEvent = exports.InvoiceCallbackEvent || (exports.InvoiceCallbackEvent = {}));
/**
 * Invoice status
 * @export
 * @enum {string}
 */
var InvoiceStatus;
(function (InvoiceStatus) {
    InvoiceStatus["New"] = "new";
    InvoiceStatus["Completed"] = "completed";
    InvoiceStatus["Unresolved"] = "unresolved";
    InvoiceStatus["Refunded"] = "refunded";
    InvoiceStatus["Cancelled"] = "cancelled";
})(InvoiceStatus = exports.InvoiceStatus || (exports.InvoiceStatus = {}));
/**
 * Invoice status context
 * @export
 * @enum {string}
 */
var InvoiceStatusContext;
(function (InvoiceStatusContext) {
    InvoiceStatusContext["Overpaid"] = "overpaid";
    InvoiceStatusContext["Underpaid"] = "underpaid";
    InvoiceStatusContext["PaidLate"] = "paid_late";
    InvoiceStatusContext["IllicitResource"] = "illicit_resource";
})(InvoiceStatusContext = exports.InvoiceStatusContext || (exports.InvoiceStatusContext = {}));
/**
 *
 * @export
 * @enum {string}
 */
var NetworkFeeLevel;
(function (NetworkFeeLevel) {
    NetworkFeeLevel["Fast"] = "fast";
    NetworkFeeLevel["Average"] = "average";
    NetworkFeeLevel["Slow"] = "slow";
})(NetworkFeeLevel = exports.NetworkFeeLevel || (exports.NetworkFeeLevel = {}));
/**
 * Transaction risk level depending on the `score` value
 * @export
 * @enum {string}
 */
var RiskLevel;
(function (RiskLevel) {
    RiskLevel["Low"] = "low";
    RiskLevel["Medium"] = "medium";
    RiskLevel["High"] = "high";
})(RiskLevel = exports.RiskLevel || (exports.RiskLevel = {}));
/**
    * @export
    * @enum {string}
    */
var RiskParamsTypeEnum;
(function (RiskParamsTypeEnum) {
    RiskParamsTypeEnum["SourceOfFunds"] = "source_of_funds";
    RiskParamsTypeEnum["DestinationOfFunds"] = "destination_of_funds";
})(RiskParamsTypeEnum = exports.RiskParamsTypeEnum || (exports.RiskParamsTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var TransactionReferenceType;
(function (TransactionReferenceType) {
    TransactionReferenceType["BankDeposit"] = "BankDeposit";
    TransactionReferenceType["BankWithdrawal"] = "BankWithdrawal";
    TransactionReferenceType["ChannelPayment"] = "ChannelPayment";
    TransactionReferenceType["CoinDeposit"] = "CoinDeposit";
    TransactionReferenceType["CoinWithdrawal"] = "CoinWithdrawal";
    TransactionReferenceType["ExchangeTransfer"] = "ExchangeTransfer";
    TransactionReferenceType["Invoice"] = "Invoice";
    TransactionReferenceType["InvoiceRefund"] = "InvoiceRefund";
    TransactionReferenceType["ManualBalanceTransaction"] = "ManualBalanceTransaction";
})(TransactionReferenceType = exports.TransactionReferenceType || (exports.TransactionReferenceType = {}));
/**
 * Accounts - axios parameter creator
 * @export
 */
exports.AccountsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: (accountId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            common_1.assertParamExists('listTransactions', 'accountId', accountId);
            const localVarPath = `/api/accounts/{account_id}/transactions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * Accounts - functional programming interface
 * @export
 */
exports.AccountsFp = function (configuration) {
    const localVarAxiosParamCreator = exports.AccountsAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accountId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactions(accountId, startingAfter, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * Accounts - factory interface
 * @export
 */
exports.AccountsFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.AccountsFp(configuration);
    return {
        /**
         *
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options) {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accountId, startingAfter, options) {
            return localVarFp.listTransactions(accountId, startingAfter, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * Accounts - object-oriented interface
 * @export
 * @class Accounts
 * @extends {BaseAPI}
 */
class Accounts extends base_1.BaseAPI {
    /**
     *
     * @summary List accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Accounts
     */
    list(options) {
        return exports.AccountsFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List account transactions
     * @param {string} accountId Account ID
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Accounts
     */
    listTransactions(accountId, startingAfter, options) {
        return exports.AccountsFp(this.configuration).listTransactions(accountId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Accounts = Accounts;
/**
 * Channels - axios parameter creator
 * @export
 */
exports.ChannelsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a channel
         * @param {ChannelParams} channelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (channelParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelParams' is not null or undefined
            common_1.assertParamExists('create', 'channelParams', channelParams);
            const localVarPath = `/api/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(channelParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (customerId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: (channelId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            common_1.assertParamExists('listPayments', 'channelId', channelId);
            const localVarPath = `/api/channels/{channel_id}/payments`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (channelId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            common_1.assertParamExists('retrieve', 'channelId', channelId);
            const localVarPath = `/api/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a channel by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: (customId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customId' is not null or undefined
            common_1.assertParamExists('retrieveByCustomId', 'customId', customId);
            const localVarPath = `/api/channels/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment: (channelId, channelPaymentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            common_1.assertParamExists('retrievePayment', 'channelId', channelId);
            // verify required parameter 'channelPaymentId' is not null or undefined
            common_1.assertParamExists('retrievePayment', 'channelPaymentId', channelPaymentId);
            const localVarPath = `/api/channels/{channel_id}/payments/{channel_payment_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"channel_payment_id"}}`, encodeURIComponent(String(channelPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (channelId, channelUpdateParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            common_1.assertParamExists('update', 'channelId', channelId);
            // verify required parameter 'channelUpdateParams' is not null or undefined
            common_1.assertParamExists('update', 'channelUpdateParams', channelUpdateParams);
            const localVarPath = `/api/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(channelUpdateParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * Channels - functional programming interface
 * @export
 */
exports.ChannelsFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ChannelsAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create a channel
         * @param {ChannelParams} channelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(channelParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(channelParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(customerId, startingAfter, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(channelId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPayments(channelId, startingAfter, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(channelId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(channelId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a channel by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveByCustomId(customId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment(channelId, channelPaymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrievePayment(channelId, channelPaymentId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(channelId, channelUpdateParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.update(channelId, channelUpdateParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * Channels - factory interface
 * @export
 */
exports.ChannelsFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ChannelsFp(configuration);
    return {
        /**
         *
         * @summary Create a channel
         * @param {ChannelParams} channelParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(channelParams, options) {
            return localVarFp.create(channelParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(channelId, startingAfter, options) {
            return localVarFp.listPayments(channelId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(channelId, options) {
            return localVarFp.retrieve(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a channel by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment(channelId, channelPaymentId, options) {
            return localVarFp.retrievePayment(channelId, channelPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(channelId, channelUpdateParams, options) {
            return localVarFp.update(channelId, channelUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * Channels - object-oriented interface
 * @export
 * @class Channels
 * @extends {BaseAPI}
 */
class Channels extends base_1.BaseAPI {
    /**
     *
     * @summary Create a channel
     * @param {ChannelParams} channelParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    create(channelParams, options) {
        return exports.ChannelsFp(this.configuration).create(channelParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List channels
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    list(customerId, startingAfter, options) {
        return exports.ChannelsFp(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List channel payments
     * @param {string} channelId Channel ID
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    listPayments(channelId, startingAfter, options) {
        return exports.ChannelsFp(this.configuration).listPayments(channelId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a channel
     * @param {string} channelId Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    retrieve(channelId, options) {
        return exports.ChannelsFp(this.configuration).retrieve(channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a channel by custom id
     * @param {string} customId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    retrieveByCustomId(customId, options) {
        return exports.ChannelsFp(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a channel payment
     * @param {string} channelId Channel ID
     * @param {string} channelPaymentId Channel payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    retrievePayment(channelId, channelPaymentId, options) {
        return exports.ChannelsFp(this.configuration).retrievePayment(channelId, channelPaymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a channel
     * @param {string} channelId Channel ID
     * @param {ChannelUpdateParams} channelUpdateParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    update(channelId, channelUpdateParams, options) {
        return exports.ChannelsFp(this.configuration).update(channelId, channelUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Channels = Channels;
/**
 * CoinWithdrawals - axios parameter creator
 * @export
 */
exports.CoinWithdrawalsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: (coinWithdrawalId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coinWithdrawalId' is not null or undefined
            common_1.assertParamExists('commit', 'coinWithdrawalId', coinWithdrawalId);
            const localVarPath = `/api/coin_withdrawals/{coin_withdrawal_id}/commit`
                .replace(`{${"coin_withdrawal_id"}}`, encodeURIComponent(String(coinWithdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (coinWithdrawalParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coinWithdrawalParams' is not null or undefined
            common_1.assertParamExists('create', 'coinWithdrawalParams', coinWithdrawalParams);
            const localVarPath = `/api/coin_withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(coinWithdrawalParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (customerId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/coin_withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List network fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/coin_withdrawals/network_fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (coinWithdrawalId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'coinWithdrawalId' is not null or undefined
            common_1.assertParamExists('retrieve', 'coinWithdrawalId', coinWithdrawalId);
            const localVarPath = `/api/coin_withdrawals/{coin_withdrawal_id}`
                .replace(`{${"coin_withdrawal_id"}}`, encodeURIComponent(String(coinWithdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: (customId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customId' is not null or undefined
            common_1.assertParamExists('retrieveByCustomId', 'customId', customId);
            const localVarPath = `/api/coin_withdrawals/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CoinWithdrawals - functional programming interface
 * @export
 */
exports.CoinWithdrawalsFp = function (configuration) {
    const localVarAxiosParamCreator = exports.CoinWithdrawalsAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(coinWithdrawalId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commit(coinWithdrawalId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(coinWithdrawalParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(coinWithdrawalParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(customerId, startingAfter, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List network fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listNetworkFees(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(coinWithdrawalId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(coinWithdrawalId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveByCustomId(customId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * CoinWithdrawals - factory interface
 * @export
 */
exports.CoinWithdrawalsFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.CoinWithdrawalsFp(configuration);
    return {
        /**
         *
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(coinWithdrawalId, options) {
            return localVarFp.commit(coinWithdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(coinWithdrawalParams, options) {
            return localVarFp.create(coinWithdrawalParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List network fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees(options) {
            return localVarFp.listNetworkFees(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(coinWithdrawalId, options) {
            return localVarFp.retrieve(coinWithdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CoinWithdrawals - object-oriented interface
 * @export
 * @class CoinWithdrawals
 * @extends {BaseAPI}
 */
class CoinWithdrawals extends base_1.BaseAPI {
    /**
     *
     * @summary Commit a withdrawal
     * @param {string} coinWithdrawalId Coin withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    commit(coinWithdrawalId, options) {
        return exports.CoinWithdrawalsFp(this.configuration).commit(coinWithdrawalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a withdrawal
     * @param {CoinWithdrawalParams} coinWithdrawalParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    create(coinWithdrawalParams, options) {
        return exports.CoinWithdrawalsFp(this.configuration).create(coinWithdrawalParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List withdrawals
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    list(customerId, startingAfter, options) {
        return exports.CoinWithdrawalsFp(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List network fees
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    listNetworkFees(options) {
        return exports.CoinWithdrawalsFp(this.configuration).listNetworkFees(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a withdrawal
     * @param {string} coinWithdrawalId Coin withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    retrieve(coinWithdrawalId, options) {
        return exports.CoinWithdrawalsFp(this.configuration).retrieve(coinWithdrawalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a withdrawal by custom id
     * @param {string} customId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    retrieveByCustomId(customId, options) {
        return exports.CoinWithdrawalsFp(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CoinWithdrawals = CoinWithdrawals;
/**
 * Customers - axios parameter creator
 * @export
 */
exports.CustomersAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a customer
         * @param {CustomerParams} customerParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (customerParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerParams' is not null or undefined
            common_1.assertParamExists('create', 'customerParams', customerParams);
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(customerParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (customerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            common_1.assertParamExists('retrieve', 'customerId', customerId);
            const localVarPath = `/api/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (customerId, customerUpdateParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            common_1.assertParamExists('update', 'customerId', customerId);
            // verify required parameter 'customerUpdateParams' is not null or undefined
            common_1.assertParamExists('update', 'customerUpdateParams', customerUpdateParams);
            const localVarPath = `/api/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(customerUpdateParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * Customers - functional programming interface
 * @export
 */
exports.CustomersFp = function (configuration) {
    const localVarAxiosParamCreator = exports.CustomersAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create a customer
         * @param {CustomerParams} customerParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(customerParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(customerParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(startingAfter, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(customerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(customerId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(customerId, customerUpdateParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.update(customerId, customerUpdateParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * Customers - factory interface
 * @export
 */
exports.CustomersFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.CustomersFp(configuration);
    return {
        /**
         *
         * @summary Create a customer
         * @param {CustomerParams} customerParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(customerParams, options) {
            return localVarFp.create(customerParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(startingAfter, options) {
            return localVarFp.list(startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(customerId, options) {
            return localVarFp.retrieve(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(customerId, customerUpdateParams, options) {
            return localVarFp.update(customerId, customerUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * Customers - object-oriented interface
 * @export
 * @class Customers
 * @extends {BaseAPI}
 */
class Customers extends base_1.BaseAPI {
    /**
     *
     * @summary Create a customer
     * @param {CustomerParams} customerParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    create(customerParams, options) {
        return exports.CustomersFp(this.configuration).create(customerParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List customers
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    list(startingAfter, options) {
        return exports.CustomersFp(this.configuration).list(startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a customer
     * @param {string} customerId The customer\&#39;s reference ID in your system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    retrieve(customerId, options) {
        return exports.CustomersFp(this.configuration).retrieve(customerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a customer
     * @param {string} customerId The customer\&#39;s reference ID in your system
     * @param {CustomerUpdateParams} customerUpdateParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    update(customerId, customerUpdateParams, options) {
        return exports.CustomersFp(this.configuration).update(customerId, customerUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Customers = Customers;
/**
 * ExchangeTransfers - axios parameter creator
 * @export
 */
exports.ExchangeTransfersAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: (exchangeTransferId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'exchangeTransferId' is not null or undefined
            common_1.assertParamExists('commit', 'exchangeTransferId', exchangeTransferId);
            const localVarPath = `/api/exchange_transfers/{exchange_transfer_id}/commit`
                .replace(`{${"exchange_transfer_id"}}`, encodeURIComponent(String(exchangeTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (exchangeTransferParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'exchangeTransferParams' is not null or undefined
            common_1.assertParamExists('create', 'exchangeTransferParams', exchangeTransferParams);
            const localVarPath = `/api/exchange_transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(exchangeTransferParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (exchangeTransferId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'exchangeTransferId' is not null or undefined
            common_1.assertParamExists('retrieve', 'exchangeTransferId', exchangeTransferId);
            const localVarPath = `/api/exchange_transfers/{exchange_transfer_id}`
                .replace(`{${"exchange_transfer_id"}}`, encodeURIComponent(String(exchangeTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ExchangeTransfers - functional programming interface
 * @export
 */
exports.ExchangeTransfersFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ExchangeTransfersAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(exchangeTransferId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commit(exchangeTransferId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(exchangeTransferParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(exchangeTransferParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(exchangeTransferId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(exchangeTransferId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ExchangeTransfers - factory interface
 * @export
 */
exports.ExchangeTransfersFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ExchangeTransfersFp(configuration);
    return {
        /**
         *
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(exchangeTransferId, options) {
            return localVarFp.commit(exchangeTransferId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(exchangeTransferParams, options) {
            return localVarFp.create(exchangeTransferParams, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(exchangeTransferId, options) {
            return localVarFp.retrieve(exchangeTransferId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExchangeTransfers - object-oriented interface
 * @export
 * @class ExchangeTransfers
 * @extends {BaseAPI}
 */
class ExchangeTransfers extends base_1.BaseAPI {
    /**
     *
     * @summary Commit an exchange transfer
     * @param {string} exchangeTransferId Exchange transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    commit(exchangeTransferId, options) {
        return exports.ExchangeTransfersFp(this.configuration).commit(exchangeTransferId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an exchange transfer
     * @param {ExchangeTransferParams} exchangeTransferParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    create(exchangeTransferParams, options) {
        return exports.ExchangeTransfersFp(this.configuration).create(exchangeTransferParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an exchange transfer
     * @param {string} exchangeTransferId Exchange transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    retrieve(exchangeTransferId, options) {
        return exports.ExchangeTransfersFp(this.configuration).retrieve(exchangeTransferId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExchangeTransfers = ExchangeTransfers;
/**
 * Invoices - axios parameter creator
 * @export
 */
exports.InvoicesAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation: (invoiceId, recalculationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('commitRecalculation', 'invoiceId', invoiceId);
            // verify required parameter 'recalculationId' is not null or undefined
            common_1.assertParamExists('commitRecalculation', 'recalculationId', recalculationId);
            const localVarPath = `/api/invoices/{invoice_id}/recalculations/{recalculation_id}/commit`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"recalculation_id"}}`, encodeURIComponent(String(recalculationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (invoiceParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceParams' is not null or undefined
            common_1.assertParamExists('create', 'invoiceParams', invoiceParams);
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(invoiceParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation: (invoiceId, invoiceRecalculationParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('createRecalculation', 'invoiceId', invoiceId);
            // verify required parameter 'invoiceRecalculationParams' is not null or undefined
            common_1.assertParamExists('createRecalculation', 'invoiceRecalculationParams', invoiceRecalculationParams);
            const localVarPath = `/api/invoices/{invoice_id}/recalculations`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(invoiceRecalculationParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund: (invoiceId, invoiceRefundParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('createRefund', 'invoiceId', invoiceId);
            // verify required parameter 'invoiceRefundParams' is not null or undefined
            common_1.assertParamExists('createRefund', 'invoiceRefundParams', invoiceRefundParams);
            const localVarPath = `/api/invoices/{invoice_id}/refunds`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(invoiceRefundParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (customerId, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds: (invoiceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('listRefunds', 'invoiceId', invoiceId);
            const localVarPath = `/api/invoices/{invoice_id}/refunds`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (invoiceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('retrieve', 'invoiceId', invoiceId);
            const localVarPath = `/api/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: (customId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customId' is not null or undefined
            common_1.assertParamExists('retrieveByCustomId', 'customId', customId);
            const localVarPath = `/api/invoices/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * Invoices - functional programming interface
 * @export
 */
exports.InvoicesFp = function (configuration) {
    const localVarAxiosParamCreator = exports.InvoicesAxiosParamCreator(configuration);
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation(invoiceId, recalculationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commitRecalculation(invoiceId, recalculationId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(invoiceParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.create(invoiceParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation(invoiceId, invoiceRecalculationParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRecalculation(invoiceId, invoiceRecalculationParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(invoiceId, invoiceRefundParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRefund(invoiceId, invoiceRefundParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(customerId, startingAfter, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRefunds(invoiceId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(invoiceId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveByCustomId(customId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * Invoices - factory interface
 * @export
 */
exports.InvoicesFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.InvoicesFp(configuration);
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation(invoiceId, recalculationId, options) {
            return localVarFp.commitRecalculation(invoiceId, recalculationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(invoiceParams, options) {
            return localVarFp.create(invoiceParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation(invoiceId, invoiceRecalculationParams, options) {
            return localVarFp.createRecalculation(invoiceId, invoiceRecalculationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(invoiceId, invoiceRefundParams, options) {
            return localVarFp.createRefund(invoiceId, invoiceRefundParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId, startingAfter, options) {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(invoiceId, options) {
            return localVarFp.listRefunds(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(invoiceId, options) {
            return localVarFp.retrieve(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId, options) {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * Invoices - object-oriented interface
 * @export
 * @class Invoices
 * @extends {BaseAPI}
 */
class Invoices extends base_1.BaseAPI {
    /**
     * This endpoint allows you to commit invoice recalculation.
     * @summary Commit invoice recalculation
     * @param {string} invoiceId Invoice ID
     * @param {string} recalculationId Recalculation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    commitRecalculation(invoiceId, recalculationId, options) {
        return exports.InvoicesFp(this.configuration).commitRecalculation(invoiceId, recalculationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to create invoices.
     * @summary Create an invoice
     * @param {InvoiceParams} invoiceParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    create(invoiceParams, options) {
        return exports.InvoicesFp(this.configuration).create(invoiceParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to recalculate invoices.
     * @summary Create invoice recalculation
     * @param {string} invoiceId Invoice ID
     * @param {InvoiceRecalculationParams} invoiceRecalculationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    createRecalculation(invoiceId, invoiceRecalculationParams, options) {
        return exports.InvoicesFp(this.configuration).createRecalculation(invoiceId, invoiceRecalculationParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to create invoice refunds.
     * @summary Create invoice refund
     * @param {string} invoiceId Invoice ID
     * @param {InvoiceRefundParams} invoiceRefundParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    createRefund(invoiceId, invoiceRefundParams, options) {
        return exports.InvoicesFp(this.configuration).createRefund(invoiceId, invoiceRefundParams, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve a list of all invoices.
     * @summary List invoices
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    list(customerId, startingAfter, options) {
        return exports.InvoicesFp(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve a list of a particular invoice refunds.
     * @summary List invoice refunds
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    listRefunds(invoiceId, options) {
        return exports.InvoicesFp(this.configuration).listRefunds(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve the invoice details.
     * @summary Retrieve an invoice
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    retrieve(invoiceId, options) {
        return exports.InvoicesFp(this.configuration).retrieve(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve invoice details by its custom_id.
     * @summary Retrieve an invoice by custom_id
     * @param {string} customId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    retrieveByCustomId(customId, options) {
        return exports.InvoicesFp(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Invoices = Invoices;
/**
 * Rates - axios parameter creator
 * @export
 */
exports.RatesAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: (baseCurrency, quoteCurrency, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'baseCurrency' is not null or undefined
            common_1.assertParamExists('retrieve', 'baseCurrency', baseCurrency);
            // verify required parameter 'quoteCurrency' is not null or undefined
            common_1.assertParamExists('retrieve', 'quoteCurrency', quoteCurrency);
            const localVarPath = `/api/rates/{base_currency}/{quote_currency}`
                .replace(`{${"base_currency"}}`, encodeURIComponent(String(baseCurrency)))
                .replace(`{${"quote_currency"}}`, encodeURIComponent(String(quoteCurrency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * Rates - functional programming interface
 * @export
 */
exports.RatesFp = function (configuration) {
    const localVarAxiosParamCreator = exports.RatesAxiosParamCreator(configuration);
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.all(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(baseCurrency, quoteCurrency, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieve(baseCurrency, quoteCurrency, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * Rates - factory interface
 * @export
 */
exports.RatesFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.RatesFp(configuration);
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options) {
            return localVarFp.all(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(baseCurrency, quoteCurrency, options) {
            return localVarFp.retrieve(baseCurrency, quoteCurrency, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * Rates - object-oriented interface
 * @export
 * @class Rates
 * @extends {BaseAPI}
 */
class Rates extends base_1.BaseAPI {
    /**
     * This endpoint allows you to retrieve all public rates.
     * @summary Retrieve all rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Rates
     */
    all(options) {
        return exports.RatesFp(this.configuration).all(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to retrieve a public rate by currency pair.
     * @summary Retrieve a pair rate
     * @param {string} baseCurrency Base currency of pair
     * @param {string} quoteCurrency Quote currency of pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Rates
     */
    retrieve(baseCurrency, quoteCurrency, options) {
        return exports.RatesFp(this.configuration).retrieve(baseCurrency, quoteCurrency, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Rates = Rates;
/**
 * Risks - axios parameter creator
 * @export
 */
exports.RisksAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Score a coin address
         * @param {RiskParams} riskParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        score: (riskParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'riskParams' is not null or undefined
            common_1.assertParamExists('score', 'riskParams', riskParams);
            const localVarPath = `/api/risks/score`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(riskParams, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * Risks - functional programming interface
 * @export
 */
exports.RisksFp = function (configuration) {
    const localVarAxiosParamCreator = exports.RisksAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Score a coin address
         * @param {RiskParams} riskParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        score(riskParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.score(riskParams, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * Risks - factory interface
 * @export
 */
exports.RisksFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.RisksFp(configuration);
    return {
        /**
         *
         * @summary Score a coin address
         * @param {RiskParams} riskParams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        score(riskParams, options) {
            return localVarFp.score(riskParams, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * Risks - object-oriented interface
 * @export
 * @class Risks
 * @extends {BaseAPI}
 */
class Risks extends base_1.BaseAPI {
    /**
     *
     * @summary Score a coin address
     * @param {RiskParams} riskParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Risks
     */
    score(riskParams, options) {
        return exports.RisksFp(this.configuration).score(riskParams, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Risks = Risks;
/**
 * Transactions - axios parameter creator
 * @export
 */
exports.TransactionsAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication HMAC required
            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom instanceof Date) ?
                    createdAtFrom.toISOString() :
                    createdAtFrom;
            }
            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo instanceof Date) ?
                    createdAtTo.toISOString() :
                    createdAtTo;
            }
            if (referenceType !== undefined) {
                localVarQueryParameter['reference_type'] = referenceType;
            }
            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (riskLevel !== undefined) {
                localVarQueryParameter['risk_level'] = riskLevel;
            }
            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * Transactions - functional programming interface
 * @export
 */
exports.TransactionsFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TransactionsAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * Transactions - factory interface
 * @export
 */
exports.TransactionsFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TransactionsFp(configuration);
    return {
        /**
         *
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options) {
            return localVarFp.list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * Transactions - object-oriented interface
 * @export
 * @class Transactions
 * @extends {BaseAPI}
 */
class Transactions extends base_1.BaseAPI {
    /**
     *
     * @summary List transactions
     * @param {string} [createdAtFrom] Date and time in iso8601 format
     * @param {string} [createdAtTo] Date and time in iso8601 format
     * @param {TransactionReferenceType} [referenceType] Transaction reference type
     * @param {string} [currency] Transaction currency
     * @param {string} [status] Transaction status
     * @param {RiskLevel} [riskLevel] Transaction risk level
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Transactions
     */
    list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options) {
        return exports.TransactionsFp(this.configuration).list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Transactions = Transactions;
