/* tslint:disable */
/* eslint-disable */
/**
 * Cryptopay API
 * Cryptopay is a payment gateway and business wallet that allows merchants to automate the processes of accepting cryptocurrency payments and payouts from their customers, as well as making currency exchange transactions and receiving data on the transaction history and account balance statuses for reporting.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Account ID
     * @type {string}
     * @memberof Account
     */
    id: string;
    /**
     * Account currency
     * @type {string}
     * @memberof Account
     */
    currency: string;
    /**
     * Account balance
     * @type {number}
     * @memberof Account
     */
    balance: number;
    /**
     * Project ID which the account belongs to
     * @type {string}
     * @memberof Account
     */
    project_id: string;
}
/**
 * 
 * @export
 * @interface AccountListResult
 */
export interface AccountListResult {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountListResult
     */
    data: Array<Account>;
    /**
     * 
     * @type {Pagination}
     * @memberof AccountListResult
     */
    meta: Pagination;
}
/**
 * @type Callback
 * @export
 */
export type Callback = ChannelPaymentCallback | CoinWithdrawalCallback | InvoiceCallback;

/**
 * 
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * Channel ID
     * @type {string}
     * @memberof Channel
     */
    id: string;
    /**
     * 
     * @type {ChannelStatus}
     * @memberof Channel
     */
    status: ChannelStatus;
    /**
     * Channel name
     * @type {string}
     * @memberof Channel
     */
    name: string;
    /**
     * Channel description
     * @type {string}
     * @memberof Channel
     */
    description: string | null;
    /**
     * The cryptocurrency which you want to accept
     * @type {string}
     * @memberof Channel
     */
    pay_currency: string;
    /**
     * The currency which all incoming transactions will be converted to
     * @type {string}
     * @memberof Channel
     */
    receiver_currency: string;
    /**
     * Channel description
     * @type {string}
     * @memberof Channel
     */
    address: string;
    /**
     * Project ID
     * @type {string}
     * @memberof Channel
     */
    project_id: string;
    /**
     * The channel reference ID in your system
     * @type {string}
     * @memberof Channel
     */
    custom_id: string | null;
    /**
     * The reference ID of your customer
     * @type {string}
     * @memberof Channel
     */
    customer_id: string | null;
    /**
     * Channel URI. May be used for generating a QR code
     * @type {string}
     * @memberof Channel
     */
    uri: string;
    /**
     * Channel hosted page that renders channel details
     * @type {string}
     * @memberof Channel
     */
    hosted_page_url: string;
}
/**
 * 
 * @export
 * @interface ChannelListResult
 */
export interface ChannelListResult {
    /**
     * 
     * @type {Array<Channel>}
     * @memberof ChannelListResult
     */
    data: Array<Channel>;
    /**
     * 
     * @type {Pagination}
     * @memberof ChannelListResult
     */
    meta: Pagination;
}
/**
 * 
 * @export
 * @interface ChannelParams
 */
export interface ChannelParams {
    /**
     * Channel name
     * @type {string}
     * @memberof ChannelParams
     */
    name: string;
    /**
     * Channel description
     * @type {string}
     * @memberof ChannelParams
     */
    description?: string;
    /**
     * The cryptocurrency which you want to accept
     * @type {string}
     * @memberof ChannelParams
     */
    pay_currency: string;
    /**
     * The currency which all incoming transactions will be converted to
     * @type {string}
     * @memberof ChannelParams
     */
    receiver_currency: string;
    /**
     * The payment reference ID in your system
     * @type {string}
     * @memberof ChannelParams
     */
    custom_id?: string;
    /**
     * The internal ID of your customer that the channel relates to
     * @type {string}
     * @memberof ChannelParams
     */
    customer_id?: string;
}
/**
 * 
 * @export
 * @interface ChannelPayment
 */
export interface ChannelPayment {
    /**
     * Channel payment ID
     * @type {string}
     * @memberof ChannelPayment
     */
    id: string;
    /**
     * Channel ID
     * @type {string}
     * @memberof ChannelPayment
     */
    channel_id: string;
    /**
     * Cryptocurrency transaction amount that was received
     * @type {number}
     * @memberof ChannelPayment
     */
    paid_amount: number;
    /**
     * Cryptocurrency type
     * @type {string}
     * @memberof ChannelPayment
     */
    paid_currency: string;
    /**
     * Amount credited to your Cryptopay account
     * @type {number}
     * @memberof ChannelPayment
     */
    received_amount: number;
    /**
     * Account currency
     * @type {string}
     * @memberof ChannelPayment
     */
    received_currency: string;
    /**
     * Processing fee
     * @type {number}
     * @memberof ChannelPayment
     */
    fee: number;
    /**
     * Processing fee currency
     * @type {string}
     * @memberof ChannelPayment
     */
    fee_currency: string;
    /**
     * Cryptocurrency transaction ID on the blockchain
     * @type {string}
     * @memberof ChannelPayment
     */
    txid: string;
    /**
     * 
     * @type {Exchange}
     * @memberof ChannelPayment
     */
    exchange?: Exchange;
    /**
     * 
     * @type {Risk}
     * @memberof ChannelPayment
     */
    risk?: Risk;
    /**
     * 
     * @type {ChannelPaymentStatus}
     * @memberof ChannelPayment
     */
    status: ChannelPaymentStatus;
    /**
     * 
     * @type {ChannelPaymentStatusContext}
     * @memberof ChannelPayment
     */
    status_context: ChannelPaymentStatusContext | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelPayment
     */
    refund_address: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelPayment
     */
    coin_withdrawal_id: string | null;
    /**
     * Channel payment custom_id value inherited from its parent channel
     * @type {string}
     * @memberof ChannelPayment
     */
    custom_id: string | null;
    /**
     * The reference ID of your customer
     * @type {string}
     * @memberof ChannelPayment
     */
    customer_id: string | null;
    /**
     * Channel cryptocurrency address
     * @type {string}
     * @memberof ChannelPayment
     */
    address?: string;
    /**
     * Channel payment creation date and time
     * @type {string}
     * @memberof ChannelPayment
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ChannelPaymentCallback
 */
export interface ChannelPaymentCallback {
    /**
     * 
     * @type {string}
     * @memberof ChannelPaymentCallback
     */
    type: string;
    /**
     * 
     * @type {ChannelPaymentCallbackEvent}
     * @memberof ChannelPaymentCallback
     */
    event: ChannelPaymentCallbackEvent;
    /**
     * 
     * @type {ChannelPayment}
     * @memberof ChannelPaymentCallback
     */
    data: ChannelPayment;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ChannelPaymentCallbackEvent {
    Created = 'created',
    OnHold = 'on_hold',
    Completed = 'completed',
    Refunded = 'refunded',
    Cancelled = 'cancelled'
}

/**
 * 
 * @export
 * @interface ChannelPaymentListResult
 */
export interface ChannelPaymentListResult {
    /**
     * 
     * @type {Array<ChannelPayment>}
     * @memberof ChannelPaymentListResult
     */
    data: Array<ChannelPayment>;
    /**
     * 
     * @type {Pagination}
     * @memberof ChannelPaymentListResult
     */
    meta: Pagination;
}
/**
 * 
 * @export
 * @interface ChannelPaymentResult
 */
export interface ChannelPaymentResult {
    /**
     * 
     * @type {ChannelPayment}
     * @memberof ChannelPaymentResult
     */
    data: ChannelPayment;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ChannelPaymentStatus {
    Pending = 'pending',
    OnHold = 'on_hold',
    Completed = 'completed',
    Refunded = 'refunded',
    Cancelled = 'cancelled'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ChannelPaymentStatusContext {
    IllicitResource = 'illicit_resource',
    ChannelDisabled = 'channel_disabled'
}

/**
 * 
 * @export
 * @interface ChannelResult
 */
export interface ChannelResult {
    /**
     * 
     * @type {Channel}
     * @memberof ChannelResult
     */
    data: Channel;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ChannelStatus {
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface ChannelUpdateParams
 */
export interface ChannelUpdateParams {
    /**
     * Channel name
     * @type {string}
     * @memberof ChannelUpdateParams
     */
    name?: string;
    /**
     * Channel description
     * @type {string}
     * @memberof ChannelUpdateParams
     */
    description?: string;
    /**
     * 
     * @type {ChannelStatus}
     * @memberof ChannelUpdateParams
     */
    status?: ChannelStatus;
    /**
     * The internal ID of your customer that the channel relates to
     * @type {string}
     * @memberof ChannelUpdateParams
     */
    customer_id?: string;
}
/**
 * 
 * @export
 * @interface CoinWithdrawal
 */
export interface CoinWithdrawal {
    /**
     * Coin withdrawal ID
     * @type {string}
     * @memberof CoinWithdrawal
     */
    id: string | null;
    /**
     * Payment reference ID in your system
     * @type {string}
     * @memberof CoinWithdrawal
     */
    custom_id: string | null;
    /**
     * The reference ID of your customer
     * @type {string}
     * @memberof CoinWithdrawal
     */
    customer_id: string | null;
    /**
     * Recipient\'s cryptocurrency wallet address
     * @type {string}
     * @memberof CoinWithdrawal
     */
    address: string;
    /**
     * Cryptocurrency transaction ID on the blockchain
     * @type {string}
     * @memberof CoinWithdrawal
     */
    txid: string | null;
    /**
     * 
     * @type {CoinWithdrawalStatus}
     * @memberof CoinWithdrawal
     */
    status: CoinWithdrawalStatus;
    /**
     * Payment amount. Amount charged from your account
     * @type {number}
     * @memberof CoinWithdrawal
     */
    charged_amount: number;
    /**
     * Account currency the payment has been sent from
     * @type {string}
     * @memberof CoinWithdrawal
     */
    charged_currency: string;
    /**
     * Cryptocurrency transaction amount. Exact amount received by a recipient
     * @type {number}
     * @memberof CoinWithdrawal
     */
    received_amount: number;
    /**
     * Cryptocurrency type
     * @type {string}
     * @memberof CoinWithdrawal
     */
    received_currency: string;
    /**
     * Network fee amount
     * @type {number}
     * @memberof CoinWithdrawal
     */
    network_fee: number;
    /**
     * 
     * @type {NetworkFeeLevel}
     * @memberof CoinWithdrawal
     */
    network_fee_level: NetworkFeeLevel;
    /**
     * 
     * @type {number}
     * @memberof CoinWithdrawal
     */
    fee: number;
    /**
     * 
     * @type {string}
     * @memberof CoinWithdrawal
     */
    fee_currency: string;
    /**
     * 
     * @type {Exchange}
     * @memberof CoinWithdrawal
     */
    exchange?: Exchange;
    /**
     * 
     * @type {Risk}
     * @memberof CoinWithdrawal
     */
    risk?: Risk;
    /**
     * Coin withdrawal creation date and time
     * @type {string}
     * @memberof CoinWithdrawal
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface CoinWithdrawalCallback
 */
export interface CoinWithdrawalCallback {
    /**
     * 
     * @type {string}
     * @memberof CoinWithdrawalCallback
     */
    type: string;
    /**
     * 
     * @type {CoinWithdrawalCallbackEvent}
     * @memberof CoinWithdrawalCallback
     */
    event: CoinWithdrawalCallbackEvent;
    /**
     * 
     * @type {CoinWithdrawal}
     * @memberof CoinWithdrawalCallback
     */
    data: CoinWithdrawal;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CoinWithdrawalCallbackEvent {
    Created = 'created',
    StatusChanged = 'status_changed'
}

/**
 * 
 * @export
 * @interface CoinWithdrawalListResult
 */
export interface CoinWithdrawalListResult {
    /**
     * 
     * @type {Array<CoinWithdrawal>}
     * @memberof CoinWithdrawalListResult
     */
    data: Array<CoinWithdrawal>;
    /**
     * 
     * @type {Pagination}
     * @memberof CoinWithdrawalListResult
     */
    meta: Pagination;
}
/**
 * 
 * @export
 * @interface CoinWithdrawalParams
 */
export interface CoinWithdrawalParams {
    /**
     * A recipient\'s cryptocurrency wallet address
     * @type {string}
     * @memberof CoinWithdrawalParams
     */
    address: string;
    /**
     * An account currency to send a transaction from
     * @type {string}
     * @memberof CoinWithdrawalParams
     */
    charged_currency: string;
    /**
     * Cryptocurrency type
     * @type {string}
     * @memberof CoinWithdrawalParams
     */
    received_currency: string;
    /**
     * All applicable fees will be deducted from this amount before processing a transaction instead of adding them on top it
     * @type {number}
     * @memberof CoinWithdrawalParams
     */
    charged_amount?: number | null;
    /**
     * An exact transaction amount to send. All applicable fees will be added on top of this amount and debited from your account
     * @type {number}
     * @memberof CoinWithdrawalParams
     */
    charged_amount_to_send?: number | null;
    /**
     * An exact transaction amount to send. All applicable fees will be added on top of this amount and debited from your account. Use this parameter if you want to send a transaction from cryptocurrency accounts only
     * @type {number}
     * @memberof CoinWithdrawalParams
     */
    received_amount?: number | null;
    /**
     * The payment reference ID in your system
     * @type {string}
     * @memberof CoinWithdrawalParams
     */
    custom_id?: string;
    /**
     * The internal ID of your customer that the wihdrawal relates to
     * @type {string}
     * @memberof CoinWithdrawalParams
     */
    customer_id?: string;
    /**
     * 
     * @type {NetworkFeeLevel}
     * @memberof CoinWithdrawalParams
     */
    network_fee_level?: NetworkFeeLevel;
    /**
     * Is `false` if omitted. Set `true` by default. Set `false` for two-step withdrawal and commit it within 30 seconds
     * @type {boolean}
     * @memberof CoinWithdrawalParams
     */
    force_commit?: boolean;
}
/**
 * 
 * @export
 * @interface CoinWithdrawalResult
 */
export interface CoinWithdrawalResult {
    /**
     * 
     * @type {CoinWithdrawal}
     * @memberof CoinWithdrawalResult
     */
    data: CoinWithdrawal;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CoinWithdrawalStatus {
    New = 'new',
    Pending = 'pending',
    OnHold = 'on_hold',
    Processing = 'processing',
    Sent = 'sent',
    Completed = 'completed',
    Failed = 'failed',
    Cancelled = 'cancelled'
}

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * The customer\'s reference ID in your system
     * @type {string}
     * @memberof Customer
     */
    id: string;
    /**
     * The customer\'s currency in your system
     * @type {string}
     * @memberof Customer
     */
    currency: string;
    /**
     * The list of refund addresses where Cryptopay will refund High-Risk transactions to
     * @type {{ [key: string]: string; }}
     * @memberof Customer
     */
    refund_addresses?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CustomerListResult
 */
export interface CustomerListResult {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerListResult
     */
    data: Array<Customer>;
    /**
     * 
     * @type {Pagination}
     * @memberof CustomerListResult
     */
    meta: Pagination;
}
/**
 * 
 * @export
 * @interface CustomerParams
 */
export interface CustomerParams {
    /**
     * The customer\'s reference ID in your system
     * @type {string}
     * @memberof CustomerParams
     */
    id: string;
    /**
     * The customer\'s currency in your system
     * @type {string}
     * @memberof CustomerParams
     */
    currency: string;
    /**
     * This object allows you to specify 1 cryptocurrency address for each type of supported cryptocurrencies i.e. BTC, ETH, XRP, LTC and BCH. In case Cryptopay detects a High-Risk transaction, such transaction will not be processed. Instead, it will be sent to the address specified for respective cryptocurrency. If you do not specify any addresses here, High-Risk payments will be put on hold
     * @type {{ [key: string]: string; }}
     * @memberof CustomerParams
     */
    refund_addresses?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CustomerResult
 */
export interface CustomerResult {
    /**
     * 
     * @type {Customer}
     * @memberof CustomerResult
     */
    data: Customer;
}
/**
 * 
 * @export
 * @interface CustomerUpdateParams
 */
export interface CustomerUpdateParams {
    /**
     * The customer\'s currency in your system
     * @type {string}
     * @memberof CustomerUpdateParams
     */
    currency?: string;
    /**
     * This object allows you to specify 1 cryptocurrency address for each type of supported cryptocurrencies i.e. BTC, ETH, XRP, LTC and BCH. In case Cryptopay detects a High-Risk transaction, such transaction will not be processed. Instead, it will be sent to the address specified for respective cryptocurrency. If you do not specify any addresses here, High-Risk payments will be put on hold
     * @type {{ [key: string]: string; }}
     * @memberof CustomerUpdateParams
     */
    refund_addresses?: { [key: string]: string; };
}
/**
 * Exchange details
 * @export
 * @interface Exchange
 */
export interface Exchange {
    /**
     * Currency pair
     * @type {string}
     * @memberof Exchange
     */
    pair: string;
    /**
     * Exchange rate
     * @type {number}
     * @memberof Exchange
     */
    rate: number;
    /**
     * Exchange fee
     * @type {number}
     * @memberof Exchange
     */
    fee?: number;
    /**
     * Exchange fee currency
     * @type {string}
     * @memberof Exchange
     */
    fee_currency?: string;
}
/**
 * 
 * @export
 * @interface ExchangeTransfer
 */
export interface ExchangeTransfer {
    /**
     * Exchange transaction ID
     * @type {string}
     * @memberof ExchangeTransfer
     */
    id: string;
    /**
     * Amount converted
     * @type {number}
     * @memberof ExchangeTransfer
     */
    charged_amount: number;
    /**
     * Account currency the funds converted from
     * @type {string}
     * @memberof ExchangeTransfer
     */
    charged_currency: string;
    /**
     * Amount to be received upon exchange execution
     * @type {number}
     * @memberof ExchangeTransfer
     */
    received_amount: number;
    /**
     * Account currency the funds converted to
     * @type {string}
     * @memberof ExchangeTransfer
     */
    received_currency: string;
    /**
     * Exchange transaction reference ID in your system
     * @type {string}
     * @memberof ExchangeTransfer
     */
    custom_id: string | null;
    /**
     * 
     * @type {Exchange}
     * @memberof ExchangeTransfer
     */
    exchange?: Exchange;
}
/**
 * 
 * @export
 * @interface ExchangeTransferParams
 */
export interface ExchangeTransferParams {
    /**
     * Account currency the funds to be converted from
     * @type {string}
     * @memberof ExchangeTransferParams
     */
    charged_currency: string;
    /**
     * Amount to be converted
     * @type {number}
     * @memberof ExchangeTransferParams
     */
    charged_amount: number | null;
    /**
     * Account currency the funds to be converted to
     * @type {string}
     * @memberof ExchangeTransferParams
     */
    received_currency: string;
    /**
     * Amount to be received upon exchange execution
     * @type {number}
     * @memberof ExchangeTransferParams
     */
    received_amount: number | null;
    /**
     * Exchange transaction reference ID in your system
     * @type {string}
     * @memberof ExchangeTransferParams
     */
    custom_id?: string;
    /**
     * Is `false` if omitted. Set `true` by default. Set `false` for two-step recalculation and commit it within 30 seconds
     * @type {boolean}
     * @memberof ExchangeTransferParams
     */
    force_commit?: boolean;
}
/**
 * 
 * @export
 * @interface ExchangeTransferResult
 */
export interface ExchangeTransferResult {
    /**
     * 
     * @type {ExchangeTransfer}
     * @memberof ExchangeTransferResult
     */
    data: ExchangeTransfer;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * Invoice ID
     * @type {string}
     * @memberof Invoice
     */
    id: string;
    /**
     * Invoice reference ID in your system
     * @type {string}
     * @memberof Invoice
     */
    custom_id: string | null;
    /**
     * The internal ID of your customer that the invoice relates to
     * @type {string}
     * @memberof Invoice
     */
    customer_id: string | null;
    /**
     * 
     * @type {InvoiceStatus}
     * @memberof Invoice
     */
    status: InvoiceStatus;
    /**
     * 
     * @type {InvoiceStatusContext}
     * @memberof Invoice
     */
    status_context: InvoiceStatusContext | null;
    /**
     * Invoice cryptocurrency address
     * @type {string}
     * @memberof Invoice
     */
    address: string;
    /**
     * Invoice URI. May be used for generating a QR code
     * @type {string}
     * @memberof Invoice
     */
    uri: string;
    /**
     * Invoice amount
     * @type {number}
     * @memberof Invoice
     */
    price_amount: number;
    /**
     * Invoice amount currency
     * @type {string}
     * @memberof Invoice
     */
    price_currency: string;
    /**
     * Processing fee
     * @type {number}
     * @memberof Invoice
     */
    fee: number;
    /**
     * Processing fee currency
     * @type {string}
     * @memberof Invoice
     */
    fee_currency: string;
    /**
     * Cryptocurrency amount to pay
     * @type {number}
     * @memberof Invoice
     */
    pay_amount: number;
    /**
     * Cryptocurrency type
     * @type {string}
     * @memberof Invoice
     */
    pay_currency: string;
    /**
     * which amount already paid
     * @type {number}
     * @memberof Invoice
     */
    paid_amount: number;
    /**
     * 
     * @type {Exchange}
     * @memberof Invoice
     */
    exchange?: Exchange;
    /**
     * 
     * @type {Array<InvoiceTransaction>}
     * @memberof Invoice
     */
    transactions: Array<InvoiceTransaction>;
    /**
     * Invoice name
     * @type {string}
     * @memberof Invoice
     */
    name: string | null;
    /**
     * Invoice description
     * @type {string}
     * @memberof Invoice
     */
    description: string | null;
    /**
     * Key-value data
     * @type {{ [key: string]: string; }}
     * @memberof Invoice
     */
    metadata: { [key: string]: string; } | null;
    /**
     * URL that a customer will be redirected to upon transaction confirmation
     * @type {string}
     * @memberof Invoice
     */
    success_redirect_url: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    unsuccess_redirect_url: string | null;
    /**
     * Invoice hosted page that renders invoice details
     * @type {string}
     * @memberof Invoice
     */
    hosted_page_url: string;
    /**
     * Invoice creation date and time
     * @type {string}
     * @memberof Invoice
     */
    created_at: string;
    /**
     * Invoice expiration date and time
     * @type {string}
     * @memberof Invoice
     */
    expires_at: string;
}
/**
 * 
 * @export
 * @interface InvoiceCallback
 */
export interface InvoiceCallback {
    /**
     * 
     * @type {string}
     * @memberof InvoiceCallback
     */
    type: string;
    /**
     * 
     * @type {InvoiceCallbackEvent}
     * @memberof InvoiceCallback
     */
    event: InvoiceCallbackEvent;
    /**
     * 
     * @type {Invoice}
     * @memberof InvoiceCallback
     */
    data: Invoice;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum InvoiceCallbackEvent {
    Created = 'created',
    Refunded = 'refunded',
    Recalculated = 'recalculated',
    StatusChanged = 'status_changed',
    TransactionCreated = 'transaction_created',
    TransactionConfirmed = 'transaction_confirmed'
}

/**
 * 
 * @export
 * @interface InvoiceListResult
 */
export interface InvoiceListResult {
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof InvoiceListResult
     */
    data: Array<Invoice>;
    /**
     * 
     * @type {Pagination}
     * @memberof InvoiceListResult
     */
    meta: Pagination;
}
/**
 * 
 * @export
 * @interface InvoiceParams
 */
export interface InvoiceParams {
    /**
     * The invoice amount
     * @type {number}
     * @memberof InvoiceParams
     */
    price_amount: number;
    /**
     * The invoice amount currency
     * @type {string}
     * @memberof InvoiceParams
     */
    price_currency: string;
    /**
     * The cryptocurrency that the invoice must be paid in
     * @type {string}
     * @memberof InvoiceParams
     */
    pay_currency: string;
    /**
     * The payment reference ID in your system
     * @type {string}
     * @memberof InvoiceParams
     */
    custom_id?: string;
    /**
     * The internal ID of your customer that the invoice relates to. See Customers for more information
     * @type {string}
     * @memberof InvoiceParams
     */
    customer_id?: string;
    /**
     * The invoice name
     * @type {string}
     * @memberof InvoiceParams
     */
    name?: string;
    /**
     * The invoice description
     * @type {string}
     * @memberof InvoiceParams
     */
    description?: string;
    /**
     * Custom key-valued data
     * @type {{ [key: string]: string; }}
     * @memberof InvoiceParams
     */
    metadata?: { [key: string]: string; };
    /**
     * The URL that the customer will be redirected to upon transaction confirmation
     * @type {string}
     * @memberof InvoiceParams
     */
    success_redirect_url?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceParams
     */
    unsuccess_redirect_url?: string;
}
/**
 * 
 * @export
 * @interface InvoiceRecalculation
 */
export interface InvoiceRecalculation {
    /**
     * Recalculation ID
     * @type {string}
     * @memberof InvoiceRecalculation
     */
    id: string;
    /**
     * Invoice ID
     * @type {string}
     * @memberof InvoiceRecalculation
     */
    invoice_id: string;
    /**
     * Cryptocurrency amount received
     * @type {number}
     * @memberof InvoiceRecalculation
     */
    pay_amount: number;
    /**
     * Cryptocurrency type
     * @type {string}
     * @memberof InvoiceRecalculation
     */
    pay_currency: string;
    /**
     * New invoice amount
     * @type {number}
     * @memberof InvoiceRecalculation
     */
    price_amount: number;
    /**
     * Invoice amount currency
     * @type {string}
     * @memberof InvoiceRecalculation
     */
    price_currency: string;
    /**
     * Processing fee
     * @type {string}
     * @memberof InvoiceRecalculation
     */
    fee: string;
    /**
     * Processing fee currency
     * @type {string}
     * @memberof InvoiceRecalculation
     */
    fee_currency: string;
    /**
     * Previous amount to pay
     * @type {number}
     * @memberof InvoiceRecalculation
     */
    previous_pay_amount: number;
    /**
     * Previous invoice amount
     * @type {number}
     * @memberof InvoiceRecalculation
     */
    previous_price_amount: number;
    /**
     * Previous exchange rate
     * @type {number}
     * @memberof InvoiceRecalculation
     */
    previous_exchange_rate: number | null;
    /**
     * 
     * @type {Exchange}
     * @memberof InvoiceRecalculation
     */
    exchange?: Exchange;
    /**
     * Recalculation creation date and time
     * @type {string}
     * @memberof InvoiceRecalculation
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface InvoiceRecalculationParams
 */
export interface InvoiceRecalculationParams {
    /**
     * Is `false` if omitted. Set `true` by default. Set `false` for two-step recalculation and commit it within 30 seconds
     * @type {boolean}
     * @memberof InvoiceRecalculationParams
     */
    force_commit?: boolean;
}
/**
 * 
 * @export
 * @interface InvoiceRecalculationResult
 */
export interface InvoiceRecalculationResult {
    /**
     * 
     * @type {InvoiceRecalculation}
     * @memberof InvoiceRecalculationResult
     */
    data: InvoiceRecalculation;
}
/**
 * 
 * @export
 * @interface InvoiceRefund
 */
export interface InvoiceRefund {
    /**
     * Refund ID
     * @type {string}
     * @memberof InvoiceRefund
     */
    id: string;
    /**
     * Invoice ID
     * @type {string}
     * @memberof InvoiceRefund
     */
    invoice_id: string;
    /**
     * Refund `custom_id`. The value is being inherited from the parent invoice
     * @type {string}
     * @memberof InvoiceRefund
     */
    custom_id: string | null;
    /**
     * Refund amount
     * @type {number}
     * @memberof InvoiceRefund
     */
    amount: number;
    /**
     * Refund currency
     * @type {string}
     * @memberof InvoiceRefund
     */
    amount_currency: string;
    /**
     * Processing fee
     * @type {number}
     * @memberof InvoiceRefund
     */
    fee: number;
    /**
     * Processing fee currency
     * @type {string}
     * @memberof InvoiceRefund
     */
    fee_currency: string;
    /**
     * Cryptocurrency address the refund transaction sent to
     * @type {string}
     * @memberof InvoiceRefund
     */
    address: string | null;
    /**
     * Cryptocurrency transaction ID on the blockchain
     * @type {string}
     * @memberof InvoiceRefund
     */
    txid: string | null;
    /**
     * 
     * @type {Risk}
     * @memberof InvoiceRefund
     */
    risk?: Risk;
    /**
     * Refund transaction creation date and time
     * @type {string}
     * @memberof InvoiceRefund
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface InvoiceRefundListResult
 */
export interface InvoiceRefundListResult {
    /**
     * 
     * @type {Array<InvoiceRefund>}
     * @memberof InvoiceRefundListResult
     */
    data: Array<InvoiceRefund>;
}
/**
 * 
 * @export
 * @interface InvoiceRefundParams
 */
export interface InvoiceRefundParams {
    /**
     * External wallet address. If not specified, the refund will be performed to your cryptocurrency account
     * @type {string}
     * @memberof InvoiceRefundParams
     */
    address?: string;
}
/**
 * 
 * @export
 * @interface InvoiceRefundResult
 */
export interface InvoiceRefundResult {
    /**
     * 
     * @type {InvoiceRefund}
     * @memberof InvoiceRefundResult
     */
    data: InvoiceRefund;
}
/**
 * 
 * @export
 * @interface InvoiceResult
 */
export interface InvoiceResult {
    /**
     * 
     * @type {Invoice}
     * @memberof InvoiceResult
     */
    data: Invoice;
}
/**
 * Invoice status
 * @export
 * @enum {string}
 */

export enum InvoiceStatus {
    New = 'new',
    Completed = 'completed',
    Unresolved = 'unresolved',
    Refunded = 'refunded',
    Cancelled = 'cancelled'
}

/**
 * Invoice status context
 * @export
 * @enum {string}
 */

export enum InvoiceStatusContext {
    Overpaid = 'overpaid',
    Underpaid = 'underpaid',
    PaidLate = 'paid_late',
    IllicitResource = 'illicit_resource'
}

/**
 * Cryptocurrency transaction hash and its risk level details
 * @export
 * @interface InvoiceTransaction
 */
export interface InvoiceTransaction {
    /**
     * Transaction hash
     * @type {string}
     * @memberof InvoiceTransaction
     */
    txid: string;
    /**
     * 
     * @type {Risk}
     * @memberof InvoiceTransaction
     */
    risk?: Risk;
}
/**
 * 
 * @export
 * @interface NetworkFee
 */
export interface NetworkFee {
    /**
     * 
     * @type {NetworkFeeLevel}
     * @memberof NetworkFee
     */
    level: NetworkFeeLevel;
    /**
     * 
     * @type {number}
     * @memberof NetworkFee
     */
    fee: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkFee
     */
    currency: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum NetworkFeeLevel {
    Fast = 'fast',
    Average = 'average',
    Slow = 'slow'
}

/**
 * 
 * @export
 * @interface NetworkFeeListResult
 */
export interface NetworkFeeListResult {
    /**
     * 
     * @type {Array<NetworkFee>}
     * @memberof NetworkFeeListResult
     */
    data: Array<NetworkFee>;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    total: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pagination
     */
    has_more: boolean;
}
/**
 * 
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * Buy rate
     * @type {number}
     * @memberof Rate
     */
    buy_rate: number;
    /**
     * Buy rate
     * @type {number}
     * @memberof Rate
     */
    sell_rate: number;
}
/**
 * 
 * @export
 * @interface RateResult
 */
export interface RateResult {
    /**
     * 
     * @type {Rate}
     * @memberof RateResult
     */
    data: Rate;
}
/**
 * 
 * @export
 * @interface RatesResult
 */
export interface RatesResult {
    /**
     * 
     * @type {{ [key: string]: Rate; }}
     * @memberof RatesResult
     */
    data: { [key: string]: Rate; };
}
/**
 * Transaction risk level details
 * @export
 * @interface Risk
 */
export interface Risk {
    /**
     * Transaction risk score
     * @type {number}
     * @memberof Risk
     */
    score: number;
    /**
     * 
     * @type {RiskLevel}
     * @memberof Risk
     */
    level: RiskLevel;
    /**
     * A resource name the transaction has been received from
     * @type {string}
     * @memberof Risk
     */
    resource_name: string;
    /**
     * A resource category the transaction has been received from
     * @type {string}
     * @memberof Risk
     */
    resource_category: string;
}
/**
 * Transaction risk level depending on the `score` value
 * @export
 * @enum {string}
 */

export enum RiskLevel {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}

/**
 * 
 * @export
 * @interface RiskParams
 */
export interface RiskParams {
    /**
     * Cryptocurrency address
     * @type {string}
     * @memberof RiskParams
     */
    address: string;
    /**
     * Cryptocurrency symbol
     * @type {string}
     * @memberof RiskParams
     */
    currency: string;
    /**
     * 
     * @type {RiskType}
     * @memberof RiskParams
     */
    type: RiskType;
}
/**
 * 
 * @export
 * @interface RiskResult
 */
export interface RiskResult {
    /**
     * 
     * @type {Risk}
     * @memberof RiskResult
     */
    data: Risk;
}
/**
 * Risk analysis type
 * @export
 * @enum {string}
 */

export enum RiskType {
    SourceOfFunds = 'source_of_funds',
    DestinationOfFunds = 'destination_of_funds'
}

/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Account transaction ID
     * @type {string}
     * @memberof Transaction
     */
    id: string;
    /**
     * Transaction description
     * @type {string}
     * @memberof Transaction
     */
    custom_id: string | null;
    /**
     * The reference ID of your customer
     * @type {string}
     * @memberof Transaction
     */
    customer_id: string | null;
    /**
     * Transaction amount
     * @type {number}
     * @memberof Transaction
     */
    amount: number;
    /**
     * Transaction currency
     * @type {string}
     * @memberof Transaction
     */
    currency: string;
    /**
     * Account subtotal
     * @type {number}
     * @memberof Transaction
     */
    balance: number;
    /**
     * Transaction fee details
     * @type {number}
     * @memberof Transaction
     */
    fee?: number;
    /**
     * Transaction fee currency
     * @type {string}
     * @memberof Transaction
     */
    fee_currency?: string;
    /**
     * Transaction reference ID in Cryptopay
     * @type {string}
     * @memberof Transaction
     */
    reference_id: string;
    /**
     * 
     * @type {TransactionReferenceType}
     * @memberof Transaction
     */
    reference_type: TransactionReferenceType;
    /**
     * Transaction description
     * @type {string}
     * @memberof Transaction
     */
    description: string | null;
    /**
     * Transaction status
     * @type {string}
     * @memberof Transaction
     */
    status: string | null;
    /**
     * Transaction status context
     * @type {string}
     * @memberof Transaction
     */
    status_context: string | null;
    /**
     * 
     * @type {Risk}
     * @memberof Transaction
     */
    risk?: Risk;
    /**
     * Transaction creation date and time
     * @type {string}
     * @memberof Transaction
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface TransactionListResult
 */
export interface TransactionListResult {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionListResult
     */
    data: Array<Transaction>;
    /**
     * 
     * @type {Pagination}
     * @memberof TransactionListResult
     */
    meta: Pagination;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum TransactionReferenceType {
    BankDeposit = 'BankDeposit',
    BankWithdrawal = 'BankWithdrawal',
    ChannelPayment = 'ChannelPayment',
    CoinDeposit = 'CoinDeposit',
    CoinWithdrawal = 'CoinWithdrawal',
    ExchangeTransfer = 'ExchangeTransfer',
    Invoice = 'Invoice',
    InvoiceRefund = 'InvoiceRefund',
    ManualBalanceTransaction = 'ManualBalanceTransaction'
}


/**
 * Accounts - axios parameter creator
 * @export
 */
export const AccountsAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: async (accountId: string, startingAfter?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listTransactions', 'accountId', accountId)
            const localVarPath = `/api/accounts/{account_id}/transactions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Accounts - functional programming interface
 * @export
 */
export const AccountsFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactions(accountId: string, startingAfter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactions(accountId, startingAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Accounts - factory interface
 * @export
 */
export const AccountsFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsFp(configuration)
    return {
        /**
         * 
         * @summary List accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<AccountListResult> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List account transactions
         * @param {string} accountId Account ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(accountId: string, startingAfter?: string, options?: any): AxiosPromise<TransactionListResult> {
            return localVarFp.listTransactions(accountId, startingAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Accounts - object-oriented interface
 * @export
 * @class Accounts
 * @extends {BaseAPI}
 */
export class Accounts extends BaseAPI {
    /**
     * 
     * @summary List accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Accounts
     */
    public list(options?: any) {
        return AccountsFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List account transactions
     * @param {string} accountId Account ID
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Accounts
     */
    public listTransactions(accountId: string, startingAfter?: string, options?: any) {
        return AccountsFp(this.configuration).listTransactions(accountId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Channels - axios parameter creator
 * @export
 */
export const ChannelsAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a channel
         * @param {ChannelParams} channelParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (channelParams: ChannelParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelParams' is not null or undefined
            assertParamExists('create', 'channelParams', channelParams)
            const localVarPath = `/api/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(channelParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (customerId?: string, startingAfter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: async (channelId: string, startingAfter?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listPayments', 'channelId', channelId)
            const localVarPath = `/api/channels/{channel_id}/payments`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (channelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('retrieve', 'channelId', channelId)
            const localVarPath = `/api/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a channel by custom id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: async (customId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customId' is not null or undefined
            assertParamExists('retrieveByCustomId', 'customId', customId)
            const localVarPath = `/api/channels/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment: async (channelId: string, channelPaymentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('retrievePayment', 'channelId', channelId)
            // verify required parameter 'channelPaymentId' is not null or undefined
            assertParamExists('retrievePayment', 'channelPaymentId', channelPaymentId)
            const localVarPath = `/api/channels/{channel_id}/payments/{channel_payment_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
                .replace(`{${"channel_payment_id"}}`, encodeURIComponent(String(channelPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (channelId: string, channelUpdateParams: ChannelUpdateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('update', 'channelId', channelId)
            // verify required parameter 'channelUpdateParams' is not null or undefined
            assertParamExists('update', 'channelUpdateParams', channelUpdateParams)
            const localVarPath = `/api/channels/{channel_id}`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(channelUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Channels - functional programming interface
 * @export
 */
export const ChannelsFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelsAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a channel
         * @param {ChannelParams} channelParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(channelParams: ChannelParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(channelParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(customerId?: string, startingAfter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(customerId, startingAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayments(channelId: string, startingAfter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelPaymentListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(channelId, startingAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(channelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a channel by custom id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveByCustomId(customId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveByCustomId(customId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePayment(channelId: string, channelPaymentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelPaymentResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePayment(channelId, channelPaymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(channelId: string, channelUpdateParams: ChannelUpdateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(channelId, channelUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Channels - factory interface
 * @export
 */
export const ChannelsFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelsFp(configuration)
    return {
        /**
         * 
         * @summary Create a channel
         * @param {ChannelParams} channelParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(channelParams: ChannelParams, options?: any): AxiosPromise<ChannelResult> {
            return localVarFp.create(channelParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List channels
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId?: string, startingAfter?: string, options?: any): AxiosPromise<ChannelListResult> {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List channel payments
         * @param {string} channelId Channel ID
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(channelId: string, startingAfter?: string, options?: any): AxiosPromise<ChannelPaymentListResult> {
            return localVarFp.listPayments(channelId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a channel
         * @param {string} channelId Channel ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(channelId: string, options?: any): AxiosPromise<ChannelResult> {
            return localVarFp.retrieve(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a channel by custom id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId: string, options?: any): AxiosPromise<ChannelResult> {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a channel payment
         * @param {string} channelId Channel ID
         * @param {string} channelPaymentId Channel payment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment(channelId: string, channelPaymentId: string, options?: any): AxiosPromise<ChannelPaymentResult> {
            return localVarFp.retrievePayment(channelId, channelPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a channel
         * @param {string} channelId Channel ID
         * @param {ChannelUpdateParams} channelUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(channelId: string, channelUpdateParams: ChannelUpdateParams, options?: any): AxiosPromise<ChannelResult> {
            return localVarFp.update(channelId, channelUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Channels - object-oriented interface
 * @export
 * @class Channels
 * @extends {BaseAPI}
 */
export class Channels extends BaseAPI {
    /**
     * 
     * @summary Create a channel
     * @param {ChannelParams} channelParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    public create(channelParams: ChannelParams, options?: any) {
        return ChannelsFp(this.configuration).create(channelParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List channels
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    public list(customerId?: string, startingAfter?: string, options?: any) {
        return ChannelsFp(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List channel payments
     * @param {string} channelId Channel ID
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    public listPayments(channelId: string, startingAfter?: string, options?: any) {
        return ChannelsFp(this.configuration).listPayments(channelId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a channel
     * @param {string} channelId Channel ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    public retrieve(channelId: string, options?: any) {
        return ChannelsFp(this.configuration).retrieve(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a channel by custom id
     * @param {string} customId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    public retrieveByCustomId(customId: string, options?: any) {
        return ChannelsFp(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a channel payment
     * @param {string} channelId Channel ID
     * @param {string} channelPaymentId Channel payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    public retrievePayment(channelId: string, channelPaymentId: string, options?: any) {
        return ChannelsFp(this.configuration).retrievePayment(channelId, channelPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a channel
     * @param {string} channelId Channel ID
     * @param {ChannelUpdateParams} channelUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Channels
     */
    public update(channelId: string, channelUpdateParams: ChannelUpdateParams, options?: any) {
        return ChannelsFp(this.configuration).update(channelId, channelUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoinWithdrawals - axios parameter creator
 * @export
 */
export const CoinWithdrawalsAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: async (coinWithdrawalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinWithdrawalId' is not null or undefined
            assertParamExists('commit', 'coinWithdrawalId', coinWithdrawalId)
            const localVarPath = `/api/coin_withdrawals/{coin_withdrawal_id}/commit`
                .replace(`{${"coin_withdrawal_id"}}`, encodeURIComponent(String(coinWithdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (coinWithdrawalParams: CoinWithdrawalParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinWithdrawalParams' is not null or undefined
            assertParamExists('create', 'coinWithdrawalParams', coinWithdrawalParams)
            const localVarPath = `/api/coin_withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coinWithdrawalParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (customerId?: string, startingAfter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/coin_withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List network fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/coin_withdrawals/network_fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (coinWithdrawalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coinWithdrawalId' is not null or undefined
            assertParamExists('retrieve', 'coinWithdrawalId', coinWithdrawalId)
            const localVarPath = `/api/coin_withdrawals/{coin_withdrawal_id}`
                .replace(`{${"coin_withdrawal_id"}}`, encodeURIComponent(String(coinWithdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: async (customId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customId' is not null or undefined
            assertParamExists('retrieveByCustomId', 'customId', customId)
            const localVarPath = `/api/coin_withdrawals/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoinWithdrawals - functional programming interface
 * @export
 */
export const CoinWithdrawalsFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoinWithdrawalsAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commit(coinWithdrawalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinWithdrawalResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commit(coinWithdrawalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(coinWithdrawalParams: CoinWithdrawalParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinWithdrawalResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(coinWithdrawalParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(customerId?: string, startingAfter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinWithdrawalListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(customerId, startingAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List network fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworkFees(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkFeeListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNetworkFees(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(coinWithdrawalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinWithdrawalResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(coinWithdrawalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveByCustomId(customId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinWithdrawalResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveByCustomId(customId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoinWithdrawals - factory interface
 * @export
 */
export const CoinWithdrawalsFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoinWithdrawalsFp(configuration)
    return {
        /**
         * 
         * @summary Commit a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(coinWithdrawalId: string, options?: any): AxiosPromise<CoinWithdrawalResult> {
            return localVarFp.commit(coinWithdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a withdrawal
         * @param {CoinWithdrawalParams} coinWithdrawalParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(coinWithdrawalParams: CoinWithdrawalParams, options?: any): AxiosPromise<CoinWithdrawalResult> {
            return localVarFp.create(coinWithdrawalParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List withdrawals
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId?: string, startingAfter?: string, options?: any): AxiosPromise<CoinWithdrawalListResult> {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List network fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkFees(options?: any): AxiosPromise<NetworkFeeListResult> {
            return localVarFp.listNetworkFees(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a withdrawal
         * @param {string} coinWithdrawalId Coin withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(coinWithdrawalId: string, options?: any): AxiosPromise<CoinWithdrawalResult> {
            return localVarFp.retrieve(coinWithdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a withdrawal by custom id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId: string, options?: any): AxiosPromise<CoinWithdrawalResult> {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoinWithdrawals - object-oriented interface
 * @export
 * @class CoinWithdrawals
 * @extends {BaseAPI}
 */
export class CoinWithdrawals extends BaseAPI {
    /**
     * 
     * @summary Commit a withdrawal
     * @param {string} coinWithdrawalId Coin withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    public commit(coinWithdrawalId: string, options?: any) {
        return CoinWithdrawalsFp(this.configuration).commit(coinWithdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a withdrawal
     * @param {CoinWithdrawalParams} coinWithdrawalParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    public create(coinWithdrawalParams: CoinWithdrawalParams, options?: any) {
        return CoinWithdrawalsFp(this.configuration).create(coinWithdrawalParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List withdrawals
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    public list(customerId?: string, startingAfter?: string, options?: any) {
        return CoinWithdrawalsFp(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List network fees
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    public listNetworkFees(options?: any) {
        return CoinWithdrawalsFp(this.configuration).listNetworkFees(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a withdrawal
     * @param {string} coinWithdrawalId Coin withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    public retrieve(coinWithdrawalId: string, options?: any) {
        return CoinWithdrawalsFp(this.configuration).retrieve(coinWithdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a withdrawal by custom id
     * @param {string} customId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoinWithdrawals
     */
    public retrieveByCustomId(customId: string, options?: any) {
        return CoinWithdrawalsFp(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Customers - axios parameter creator
 * @export
 */
export const CustomersAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a customer
         * @param {CustomerParams} customerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (customerParams: CustomerParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerParams' is not null or undefined
            assertParamExists('create', 'customerParams', customerParams)
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (startingAfter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('retrieve', 'customerId', customerId)
            const localVarPath = `/api/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (customerId: string, customerUpdateParams: CustomerUpdateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('update', 'customerId', customerId)
            // verify required parameter 'customerUpdateParams' is not null or undefined
            assertParamExists('update', 'customerUpdateParams', customerUpdateParams)
            const localVarPath = `/api/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Customers - functional programming interface
 * @export
 */
export const CustomersFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a customer
         * @param {CustomerParams} customerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(customerParams: CustomerParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(customerParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(startingAfter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(startingAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(customerId: string, customerUpdateParams: CustomerUpdateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(customerId, customerUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Customers - factory interface
 * @export
 */
export const CustomersFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersFp(configuration)
    return {
        /**
         * 
         * @summary Create a customer
         * @param {CustomerParams} customerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(customerParams: CustomerParams, options?: any): AxiosPromise<CustomerResult> {
            return localVarFp.create(customerParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List customers
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(startingAfter?: string, options?: any): AxiosPromise<CustomerListResult> {
            return localVarFp.list(startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(customerId: string, options?: any): AxiosPromise<CustomerResult> {
            return localVarFp.retrieve(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a customer
         * @param {string} customerId The customer\&#39;s reference ID in your system
         * @param {CustomerUpdateParams} customerUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(customerId: string, customerUpdateParams: CustomerUpdateParams, options?: any): AxiosPromise<CustomerResult> {
            return localVarFp.update(customerId, customerUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Customers - object-oriented interface
 * @export
 * @class Customers
 * @extends {BaseAPI}
 */
export class Customers extends BaseAPI {
    /**
     * 
     * @summary Create a customer
     * @param {CustomerParams} customerParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    public create(customerParams: CustomerParams, options?: any) {
        return CustomersFp(this.configuration).create(customerParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List customers
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    public list(startingAfter?: string, options?: any) {
        return CustomersFp(this.configuration).list(startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a customer
     * @param {string} customerId The customer\&#39;s reference ID in your system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    public retrieve(customerId: string, options?: any) {
        return CustomersFp(this.configuration).retrieve(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a customer
     * @param {string} customerId The customer\&#39;s reference ID in your system
     * @param {CustomerUpdateParams} customerUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Customers
     */
    public update(customerId: string, customerUpdateParams: CustomerUpdateParams, options?: any) {
        return CustomersFp(this.configuration).update(customerId, customerUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExchangeTransfers - axios parameter creator
 * @export
 */
export const ExchangeTransfersAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit: async (exchangeTransferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeTransferId' is not null or undefined
            assertParamExists('commit', 'exchangeTransferId', exchangeTransferId)
            const localVarPath = `/api/exchange_transfers/{exchange_transfer_id}/commit`
                .replace(`{${"exchange_transfer_id"}}`, encodeURIComponent(String(exchangeTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (exchangeTransferParams: ExchangeTransferParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeTransferParams' is not null or undefined
            assertParamExists('create', 'exchangeTransferParams', exchangeTransferParams)
            const localVarPath = `/api/exchange_transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exchangeTransferParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (exchangeTransferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeTransferId' is not null or undefined
            assertParamExists('retrieve', 'exchangeTransferId', exchangeTransferId)
            const localVarPath = `/api/exchange_transfers/{exchange_transfer_id}`
                .replace(`{${"exchange_transfer_id"}}`, encodeURIComponent(String(exchangeTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeTransfers - functional programming interface
 * @export
 */
export const ExchangeTransfersFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangeTransfersAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commit(exchangeTransferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeTransferResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commit(exchangeTransferId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(exchangeTransferParams: ExchangeTransferParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeTransferResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(exchangeTransferParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(exchangeTransferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeTransferResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(exchangeTransferId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExchangeTransfers - factory interface
 * @export
 */
export const ExchangeTransfersFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangeTransfersFp(configuration)
    return {
        /**
         * 
         * @summary Commit an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commit(exchangeTransferId: string, options?: any): AxiosPromise<ExchangeTransferResult> {
            return localVarFp.commit(exchangeTransferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an exchange transfer
         * @param {ExchangeTransferParams} exchangeTransferParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(exchangeTransferParams: ExchangeTransferParams, options?: any): AxiosPromise<ExchangeTransferResult> {
            return localVarFp.create(exchangeTransferParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an exchange transfer
         * @param {string} exchangeTransferId Exchange transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(exchangeTransferId: string, options?: any): AxiosPromise<ExchangeTransferResult> {
            return localVarFp.retrieve(exchangeTransferId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangeTransfers - object-oriented interface
 * @export
 * @class ExchangeTransfers
 * @extends {BaseAPI}
 */
export class ExchangeTransfers extends BaseAPI {
    /**
     * 
     * @summary Commit an exchange transfer
     * @param {string} exchangeTransferId Exchange transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    public commit(exchangeTransferId: string, options?: any) {
        return ExchangeTransfersFp(this.configuration).commit(exchangeTransferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an exchange transfer
     * @param {ExchangeTransferParams} exchangeTransferParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    public create(exchangeTransferParams: ExchangeTransferParams, options?: any) {
        return ExchangeTransfersFp(this.configuration).create(exchangeTransferParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an exchange transfer
     * @param {string} exchangeTransferId Exchange transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeTransfers
     */
    public retrieve(exchangeTransferId: string, options?: any) {
        return ExchangeTransfersFp(this.configuration).retrieve(exchangeTransferId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Invoices - axios parameter creator
 * @export
 */
export const InvoicesAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation: async (invoiceId: string, recalculationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('commitRecalculation', 'invoiceId', invoiceId)
            // verify required parameter 'recalculationId' is not null or undefined
            assertParamExists('commitRecalculation', 'recalculationId', recalculationId)
            const localVarPath = `/api/invoices/{invoice_id}/recalculations/{recalculation_id}/commit`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"recalculation_id"}}`, encodeURIComponent(String(recalculationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (invoiceParams: InvoiceParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceParams' is not null or undefined
            assertParamExists('create', 'invoiceParams', invoiceParams)
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation: async (invoiceId: string, invoiceRecalculationParams: InvoiceRecalculationParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('createRecalculation', 'invoiceId', invoiceId)
            // verify required parameter 'invoiceRecalculationParams' is not null or undefined
            assertParamExists('createRecalculation', 'invoiceRecalculationParams', invoiceRecalculationParams)
            const localVarPath = `/api/invoices/{invoice_id}/recalculations`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRecalculationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund: async (invoiceId: string, invoiceRefundParams: InvoiceRefundParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('createRefund', 'invoiceId', invoiceId)
            // verify required parameter 'invoiceRefundParams' is not null or undefined
            assertParamExists('createRefund', 'invoiceRefundParams', invoiceRefundParams)
            const localVarPath = `/api/invoices/{invoice_id}/refunds`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceRefundParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (customerId?: string, startingAfter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds: async (invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('listRefunds', 'invoiceId', invoiceId)
            const localVarPath = `/api/invoices/{invoice_id}/refunds`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('retrieve', 'invoiceId', invoiceId)
            const localVarPath = `/api/invoices/{invoice_id}`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId: async (customId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customId' is not null or undefined
            assertParamExists('retrieveByCustomId', 'customId', customId)
            const localVarPath = `/api/invoices/custom_id/{custom_id}`
                .replace(`{${"custom_id"}}`, encodeURIComponent(String(customId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Invoices - functional programming interface
 * @export
 */
export const InvoicesFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitRecalculation(invoiceId: string, recalculationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceRecalculationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitRecalculation(invoiceId, recalculationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(invoiceParams: InvoiceParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(invoiceParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecalculation(invoiceId: string, invoiceRecalculationParams: InvoiceRecalculationParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceRecalculationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecalculation(invoiceId, invoiceRecalculationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRefund(invoiceId: string, invoiceRefundParams: InvoiceRefundParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceRefundResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRefund(invoiceId, invoiceRefundParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(customerId?: string, startingAfter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(customerId, startingAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRefunds(invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceRefundListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRefunds(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveByCustomId(customId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveByCustomId(customId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Invoices - factory interface
 * @export
 */
export const InvoicesFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesFp(configuration)
    return {
        /**
         * This endpoint allows you to commit invoice recalculation.
         * @summary Commit invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {string} recalculationId Recalculation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitRecalculation(invoiceId: string, recalculationId: string, options?: any): AxiosPromise<InvoiceRecalculationResult> {
            return localVarFp.commitRecalculation(invoiceId, recalculationId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create invoices.
         * @summary Create an invoice
         * @param {InvoiceParams} invoiceParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(invoiceParams: InvoiceParams, options?: any): AxiosPromise<InvoiceResult> {
            return localVarFp.create(invoiceParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to recalculate invoices.
         * @summary Create invoice recalculation
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRecalculationParams} invoiceRecalculationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecalculation(invoiceId: string, invoiceRecalculationParams: InvoiceRecalculationParams, options?: any): AxiosPromise<InvoiceRecalculationResult> {
            return localVarFp.createRecalculation(invoiceId, invoiceRecalculationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create invoice refunds.
         * @summary Create invoice refund
         * @param {string} invoiceId Invoice ID
         * @param {InvoiceRefundParams} invoiceRefundParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(invoiceId: string, invoiceRefundParams: InvoiceRefundParams, options?: any): AxiosPromise<InvoiceRefundResult> {
            return localVarFp.createRefund(invoiceId, invoiceRefundParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a list of all invoices.
         * @summary List invoices
         * @param {string} [customerId] The internal ID of your customer that the transaction relates to
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(customerId?: string, startingAfter?: string, options?: any): AxiosPromise<InvoiceListResult> {
            return localVarFp.list(customerId, startingAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a list of a particular invoice refunds.
         * @summary List invoice refunds
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(invoiceId: string, options?: any): AxiosPromise<InvoiceRefundListResult> {
            return localVarFp.listRefunds(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve the invoice details.
         * @summary Retrieve an invoice
         * @param {string} invoiceId Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(invoiceId: string, options?: any): AxiosPromise<InvoiceResult> {
            return localVarFp.retrieve(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve invoice details by its custom_id.
         * @summary Retrieve an invoice by custom_id
         * @param {string} customId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveByCustomId(customId: string, options?: any): AxiosPromise<InvoiceResult> {
            return localVarFp.retrieveByCustomId(customId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Invoices - object-oriented interface
 * @export
 * @class Invoices
 * @extends {BaseAPI}
 */
export class Invoices extends BaseAPI {
    /**
     * This endpoint allows you to commit invoice recalculation.
     * @summary Commit invoice recalculation
     * @param {string} invoiceId Invoice ID
     * @param {string} recalculationId Recalculation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public commitRecalculation(invoiceId: string, recalculationId: string, options?: any) {
        return InvoicesFp(this.configuration).commitRecalculation(invoiceId, recalculationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to create invoices.
     * @summary Create an invoice
     * @param {InvoiceParams} invoiceParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public create(invoiceParams: InvoiceParams, options?: any) {
        return InvoicesFp(this.configuration).create(invoiceParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to recalculate invoices.
     * @summary Create invoice recalculation
     * @param {string} invoiceId Invoice ID
     * @param {InvoiceRecalculationParams} invoiceRecalculationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public createRecalculation(invoiceId: string, invoiceRecalculationParams: InvoiceRecalculationParams, options?: any) {
        return InvoicesFp(this.configuration).createRecalculation(invoiceId, invoiceRecalculationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to create invoice refunds.
     * @summary Create invoice refund
     * @param {string} invoiceId Invoice ID
     * @param {InvoiceRefundParams} invoiceRefundParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public createRefund(invoiceId: string, invoiceRefundParams: InvoiceRefundParams, options?: any) {
        return InvoicesFp(this.configuration).createRefund(invoiceId, invoiceRefundParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to retrieve a list of all invoices.
     * @summary List invoices
     * @param {string} [customerId] The internal ID of your customer that the transaction relates to
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public list(customerId?: string, startingAfter?: string, options?: any) {
        return InvoicesFp(this.configuration).list(customerId, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to retrieve a list of a particular invoice refunds.
     * @summary List invoice refunds
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public listRefunds(invoiceId: string, options?: any) {
        return InvoicesFp(this.configuration).listRefunds(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to retrieve the invoice details.
     * @summary Retrieve an invoice
     * @param {string} invoiceId Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public retrieve(invoiceId: string, options?: any) {
        return InvoicesFp(this.configuration).retrieve(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to retrieve invoice details by its custom_id.
     * @summary Retrieve an invoice by custom_id
     * @param {string} customId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Invoices
     */
    public retrieveByCustomId(customId: string, options?: any) {
        return InvoicesFp(this.configuration).retrieveByCustomId(customId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Rates - axios parameter creator
 * @export
 */
export const RatesAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (baseCurrency: string, quoteCurrency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseCurrency' is not null or undefined
            assertParamExists('retrieve', 'baseCurrency', baseCurrency)
            // verify required parameter 'quoteCurrency' is not null or undefined
            assertParamExists('retrieve', 'quoteCurrency', quoteCurrency)
            const localVarPath = `/api/rates/{base_currency}/{quote_currency}`
                .replace(`{${"base_currency"}}`, encodeURIComponent(String(baseCurrency)))
                .replace(`{${"quote_currency"}}`, encodeURIComponent(String(quoteCurrency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Rates - functional programming interface
 * @export
 */
export const RatesFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatesAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async all(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatesResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.all(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(baseCurrency: string, quoteCurrency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(baseCurrency, quoteCurrency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Rates - factory interface
 * @export
 */
export const RatesFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatesFp(configuration)
    return {
        /**
         * This endpoint allows you to retrieve all public rates.
         * @summary Retrieve all rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options?: any): AxiosPromise<RatesResult> {
            return localVarFp.all(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to retrieve a public rate by currency pair.
         * @summary Retrieve a pair rate
         * @param {string} baseCurrency Base currency of pair
         * @param {string} quoteCurrency Quote currency of pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(baseCurrency: string, quoteCurrency: string, options?: any): AxiosPromise<RateResult> {
            return localVarFp.retrieve(baseCurrency, quoteCurrency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Rates - object-oriented interface
 * @export
 * @class Rates
 * @extends {BaseAPI}
 */
export class Rates extends BaseAPI {
    /**
     * This endpoint allows you to retrieve all public rates.
     * @summary Retrieve all rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Rates
     */
    public all(options?: any) {
        return RatesFp(this.configuration).all(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to retrieve a public rate by currency pair.
     * @summary Retrieve a pair rate
     * @param {string} baseCurrency Base currency of pair
     * @param {string} quoteCurrency Quote currency of pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Rates
     */
    public retrieve(baseCurrency: string, quoteCurrency: string, options?: any) {
        return RatesFp(this.configuration).retrieve(baseCurrency, quoteCurrency, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Risks - axios parameter creator
 * @export
 */
export const RisksAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Score a coin address
         * @param {RiskParams} riskParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        score: async (riskParams: RiskParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'riskParams' is not null or undefined
            assertParamExists('score', 'riskParams', riskParams)
            const localVarPath = `/api/risks/score`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(riskParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Risks - functional programming interface
 * @export
 */
export const RisksFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RisksAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Score a coin address
         * @param {RiskParams} riskParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async score(riskParams: RiskParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RiskResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.score(riskParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Risks - factory interface
 * @export
 */
export const RisksFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RisksFp(configuration)
    return {
        /**
         * 
         * @summary Score a coin address
         * @param {RiskParams} riskParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        score(riskParams: RiskParams, options?: any): AxiosPromise<RiskResult> {
            return localVarFp.score(riskParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Risks - object-oriented interface
 * @export
 * @class Risks
 * @extends {BaseAPI}
 */
export class Risks extends BaseAPI {
    /**
     * 
     * @summary Score a coin address
     * @param {RiskParams} riskParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Risks
     */
    public score(riskParams: RiskParams, options?: any) {
        return RisksFp(this.configuration).score(riskParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Transactions - axios parameter creator
 * @export
 */
export const TransactionsAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (createdAtFrom?: string, createdAtTo?: string, referenceType?: TransactionReferenceType, currency?: string, status?: string, riskLevel?: RiskLevel, startingAfter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HMAC required

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = (createdAtFrom as any instanceof Date) ?
                    (createdAtFrom as any).toISOString() :
                    createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = (createdAtTo as any instanceof Date) ?
                    (createdAtTo as any).toISOString() :
                    createdAtTo;
            }

            if (referenceType !== undefined) {
                localVarQueryParameter['reference_type'] = referenceType;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (riskLevel !== undefined) {
                localVarQueryParameter['risk_level'] = riskLevel;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Transactions - functional programming interface
 * @export
 */
export const TransactionsFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(createdAtFrom?: string, createdAtTo?: string, referenceType?: TransactionReferenceType, currency?: string, status?: string, riskLevel?: RiskLevel, startingAfter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionListResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Transactions - factory interface
 * @export
 */
export const TransactionsFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsFp(configuration)
    return {
        /**
         * 
         * @summary List transactions
         * @param {string} [createdAtFrom] Date and time in iso8601 format
         * @param {string} [createdAtTo] Date and time in iso8601 format
         * @param {TransactionReferenceType} [referenceType] Transaction reference type
         * @param {string} [currency] Transaction currency
         * @param {string} [status] Transaction status
         * @param {RiskLevel} [riskLevel] Transaction risk level
         * @param {string} [startingAfter] Pagination parameter. ID to start after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(createdAtFrom?: string, createdAtTo?: string, referenceType?: TransactionReferenceType, currency?: string, status?: string, riskLevel?: RiskLevel, startingAfter?: string, options?: any): AxiosPromise<TransactionListResult> {
            return localVarFp.list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Transactions - object-oriented interface
 * @export
 * @class Transactions
 * @extends {BaseAPI}
 */
export class Transactions extends BaseAPI {
    /**
     * 
     * @summary List transactions
     * @param {string} [createdAtFrom] Date and time in iso8601 format
     * @param {string} [createdAtTo] Date and time in iso8601 format
     * @param {TransactionReferenceType} [referenceType] Transaction reference type
     * @param {string} [currency] Transaction currency
     * @param {string} [status] Transaction status
     * @param {RiskLevel} [riskLevel] Transaction risk level
     * @param {string} [startingAfter] Pagination parameter. ID to start after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Transactions
     */
    public list(createdAtFrom?: string, createdAtTo?: string, referenceType?: TransactionReferenceType, currency?: string, status?: string, riskLevel?: RiskLevel, startingAfter?: string, options?: any) {
        return TransactionsFp(this.configuration).list(createdAtFrom, createdAtTo, referenceType, currency, status, riskLevel, startingAfter, options).then((request) => request(this.axios, this.basePath));
    }
}


